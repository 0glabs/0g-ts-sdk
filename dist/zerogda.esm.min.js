import fs from"fs";import path from"path";import{open}from"node:fs/promises";var commonjsGlobal=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof global!=="undefined"?global:typeof self!=="undefined"?self:{};function getDefaultExportFromCjs(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x["default"]:x}var sha3$1={exports:{}};(function(module){(function(){var INPUT_ERROR="input is invalid type";var FINALIZE_ERROR="finalize already called";var WINDOW=typeof window==="object";var root=WINDOW?window:{};if(root.JS_SHA3_NO_WINDOW){WINDOW=false}var WEB_WORKER=!WINDOW&&typeof self==="object";var NODE_JS=!root.JS_SHA3_NO_NODE_JS&&typeof process==="object"&&process.versions&&process.versions.node;if(NODE_JS){root=commonjsGlobal}else if(WEB_WORKER){root=self}var COMMON_JS=!root.JS_SHA3_NO_COMMON_JS&&"object"==="object"&&module.exports;var ARRAY_BUFFER=!root.JS_SHA3_NO_ARRAY_BUFFER&&typeof ArrayBuffer!=="undefined";var HEX_CHARS="0123456789abcdef".split("");var SHAKE_PADDING=[31,7936,2031616,520093696];var CSHAKE_PADDING=[4,1024,262144,67108864];var KECCAK_PADDING=[1,256,65536,16777216];var PADDING=[6,1536,393216,100663296];var SHIFT=[0,8,16,24];var RC=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648];var BITS=[224,256,384,512];var SHAKE_BITS=[128,256];var OUTPUT_TYPES=["hex","buffer","arrayBuffer","array","digest"];var CSHAKE_BYTEPAD={128:168,256:136};if(root.JS_SHA3_NO_NODE_JS||!Array.isArray){Array.isArray=function(obj){return Object.prototype.toString.call(obj)==="[object Array]"}}if(ARRAY_BUFFER&&(root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)){ArrayBuffer.isView=function(obj){return typeof obj==="object"&&obj.buffer&&obj.buffer.constructor===ArrayBuffer}}var createOutputMethod=function(bits,padding,outputType){return function(message){return new Keccak(bits,padding,bits).update(message)[outputType]()}};var createShakeOutputMethod=function(bits,padding,outputType){return function(message,outputBits){return new Keccak(bits,padding,outputBits).update(message)[outputType]()}};var createCshakeOutputMethod=function(bits,padding,outputType){return function(message,outputBits,n,s){return methods["cshake"+bits].update(message,outputBits,n,s)[outputType]()}};var createKmacOutputMethod=function(bits,padding,outputType){return function(key,message,outputBits,s){return methods["kmac"+bits].update(key,message,outputBits,s)[outputType]()}};var createOutputMethods=function(method,createMethod,bits,padding){for(var i=0;i<OUTPUT_TYPES.length;++i){var type=OUTPUT_TYPES[i];method[type]=createMethod(bits,padding,type)}return method};var createMethod=function(bits,padding){var method=createOutputMethod(bits,padding,"hex");method.create=function(){return new Keccak(bits,padding,bits)};method.update=function(message){return method.create().update(message)};return createOutputMethods(method,createOutputMethod,bits,padding)};var createShakeMethod=function(bits,padding){var method=createShakeOutputMethod(bits,padding,"hex");method.create=function(outputBits){return new Keccak(bits,padding,outputBits)};method.update=function(message,outputBits){return method.create(outputBits).update(message)};return createOutputMethods(method,createShakeOutputMethod,bits,padding)};var createCshakeMethod=function(bits,padding){var w=CSHAKE_BYTEPAD[bits];var method=createCshakeOutputMethod(bits,padding,"hex");method.create=function(outputBits,n,s){if(!n&&!s){return methods["shake"+bits].create(outputBits)}else{return new Keccak(bits,padding,outputBits).bytepad([n,s],w)}};method.update=function(message,outputBits,n,s){return method.create(outputBits,n,s).update(message)};return createOutputMethods(method,createCshakeOutputMethod,bits,padding)};var createKmacMethod=function(bits,padding){var w=CSHAKE_BYTEPAD[bits];var method=createKmacOutputMethod(bits,padding,"hex");method.create=function(key,outputBits,s){return new Kmac(bits,padding,outputBits).bytepad(["KMAC",s],w).bytepad([key],w)};method.update=function(key,message,outputBits,s){return method.create(key,outputBits,s).update(message)};return createOutputMethods(method,createKmacOutputMethod,bits,padding)};var algorithms=[{name:"keccak",padding:KECCAK_PADDING,bits:BITS,createMethod:createMethod},{name:"sha3",padding:PADDING,bits:BITS,createMethod:createMethod},{name:"shake",padding:SHAKE_PADDING,bits:SHAKE_BITS,createMethod:createShakeMethod},{name:"cshake",padding:CSHAKE_PADDING,bits:SHAKE_BITS,createMethod:createCshakeMethod},{name:"kmac",padding:CSHAKE_PADDING,bits:SHAKE_BITS,createMethod:createKmacMethod}];var methods={},methodNames=[];for(var i=0;i<algorithms.length;++i){var algorithm=algorithms[i];var bits=algorithm.bits;for(var j=0;j<bits.length;++j){var methodName=algorithm.name+"_"+bits[j];methodNames.push(methodName);methods[methodName]=algorithm.createMethod(bits[j],algorithm.padding);if(algorithm.name!=="sha3"){var newMethodName=algorithm.name+bits[j];methodNames.push(newMethodName);methods[newMethodName]=methods[methodName]}}}function Keccak(bits,padding,outputBits){this.blocks=[];this.s=[];this.padding=padding;this.outputBits=outputBits;this.reset=true;this.finalized=false;this.block=0;this.start=0;this.blockCount=1600-(bits<<1)>>5;this.byteCount=this.blockCount<<2;this.outputBlocks=outputBits>>5;this.extraBytes=(outputBits&31)>>3;for(var i=0;i<50;++i){this.s[i]=0}}Keccak.prototype.update=function(message){if(this.finalized){throw new Error(FINALIZE_ERROR)}var notString,type=typeof message;if(type!=="string"){if(type==="object"){if(message===null){throw new Error(INPUT_ERROR)}else if(ARRAY_BUFFER&&message.constructor===ArrayBuffer){message=new Uint8Array(message)}else if(!Array.isArray(message)){if(!ARRAY_BUFFER||!ArrayBuffer.isView(message)){throw new Error(INPUT_ERROR)}}}else{throw new Error(INPUT_ERROR)}notString=true}var blocks=this.blocks,byteCount=this.byteCount,length=message.length,blockCount=this.blockCount,index=0,s=this.s,i,code;while(index<length){if(this.reset){this.reset=false;blocks[0]=this.block;for(i=1;i<blockCount+1;++i){blocks[i]=0}}if(notString){for(i=this.start;index<length&&i<byteCount;++index){blocks[i>>2]|=message[index]<<SHIFT[i++&3]}}else{for(i=this.start;index<length&&i<byteCount;++index){code=message.charCodeAt(index);if(code<128){blocks[i>>2]|=code<<SHIFT[i++&3]}else if(code<2048){blocks[i>>2]|=(192|code>>6)<<SHIFT[i++&3];blocks[i>>2]|=(128|code&63)<<SHIFT[i++&3]}else if(code<55296||code>=57344){blocks[i>>2]|=(224|code>>12)<<SHIFT[i++&3];blocks[i>>2]|=(128|code>>6&63)<<SHIFT[i++&3];blocks[i>>2]|=(128|code&63)<<SHIFT[i++&3]}else{code=65536+((code&1023)<<10|message.charCodeAt(++index)&1023);blocks[i>>2]|=(240|code>>18)<<SHIFT[i++&3];blocks[i>>2]|=(128|code>>12&63)<<SHIFT[i++&3];blocks[i>>2]|=(128|code>>6&63)<<SHIFT[i++&3];blocks[i>>2]|=(128|code&63)<<SHIFT[i++&3]}}}this.lastByteIndex=i;if(i>=byteCount){this.start=i-byteCount;this.block=blocks[blockCount];for(i=0;i<blockCount;++i){s[i]^=blocks[i]}f(s);this.reset=true}else{this.start=i}}return this};Keccak.prototype.encode=function(x,right){var o=x&255,n=1;var bytes=[o];x=x>>8;o=x&255;while(o>0){bytes.unshift(o);x=x>>8;o=x&255;++n}if(right){bytes.push(n)}else{bytes.unshift(n)}this.update(bytes);return bytes.length};Keccak.prototype.encodeString=function(str){var notString,type=typeof str;if(type!=="string"){if(type==="object"){if(str===null){throw new Error(INPUT_ERROR)}else if(ARRAY_BUFFER&&str.constructor===ArrayBuffer){str=new Uint8Array(str)}else if(!Array.isArray(str)){if(!ARRAY_BUFFER||!ArrayBuffer.isView(str)){throw new Error(INPUT_ERROR)}}}else{throw new Error(INPUT_ERROR)}notString=true}var bytes=0,length=str.length;if(notString){bytes=length}else{for(var i=0;i<str.length;++i){var code=str.charCodeAt(i);if(code<128){bytes+=1}else if(code<2048){bytes+=2}else if(code<55296||code>=57344){bytes+=3}else{code=65536+((code&1023)<<10|str.charCodeAt(++i)&1023);bytes+=4}}}bytes+=this.encode(bytes*8);this.update(str);return bytes};Keccak.prototype.bytepad=function(strs,w){var bytes=this.encode(w);for(var i=0;i<strs.length;++i){bytes+=this.encodeString(strs[i])}var paddingBytes=w-bytes%w;var zeros=[];zeros.length=paddingBytes;this.update(zeros);return this};Keccak.prototype.finalize=function(){if(this.finalized){return}this.finalized=true;var blocks=this.blocks,i=this.lastByteIndex,blockCount=this.blockCount,s=this.s;blocks[i>>2]|=this.padding[i&3];if(this.lastByteIndex===this.byteCount){blocks[0]=blocks[blockCount];for(i=1;i<blockCount+1;++i){blocks[i]=0}}blocks[blockCount-1]|=2147483648;for(i=0;i<blockCount;++i){s[i]^=blocks[i]}f(s)};Keccak.prototype.toString=Keccak.prototype.hex=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var hex="",block;while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){block=s[i];hex+=HEX_CHARS[block>>4&15]+HEX_CHARS[block&15]+HEX_CHARS[block>>12&15]+HEX_CHARS[block>>8&15]+HEX_CHARS[block>>20&15]+HEX_CHARS[block>>16&15]+HEX_CHARS[block>>28&15]+HEX_CHARS[block>>24&15]}if(j%blockCount===0){f(s);i=0}}if(extraBytes){block=s[i];hex+=HEX_CHARS[block>>4&15]+HEX_CHARS[block&15];if(extraBytes>1){hex+=HEX_CHARS[block>>12&15]+HEX_CHARS[block>>8&15]}if(extraBytes>2){hex+=HEX_CHARS[block>>20&15]+HEX_CHARS[block>>16&15]}}return hex};Keccak.prototype.arrayBuffer=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var bytes=this.outputBits>>3;var buffer;if(extraBytes){buffer=new ArrayBuffer(outputBlocks+1<<2)}else{buffer=new ArrayBuffer(bytes)}var array=new Uint32Array(buffer);while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){array[j]=s[i]}if(j%blockCount===0){f(s)}}if(extraBytes){array[i]=s[i];buffer=buffer.slice(0,bytes)}return buffer};Keccak.prototype.buffer=Keccak.prototype.arrayBuffer;Keccak.prototype.digest=Keccak.prototype.array=function(){this.finalize();var blockCount=this.blockCount,s=this.s,outputBlocks=this.outputBlocks,extraBytes=this.extraBytes,i=0,j=0;var array=[],offset,block;while(j<outputBlocks){for(i=0;i<blockCount&&j<outputBlocks;++i,++j){offset=j<<2;block=s[i];array[offset]=block&255;array[offset+1]=block>>8&255;array[offset+2]=block>>16&255;array[offset+3]=block>>24&255}if(j%blockCount===0){f(s)}}if(extraBytes){offset=j<<2;block=s[i];array[offset]=block&255;if(extraBytes>1){array[offset+1]=block>>8&255}if(extraBytes>2){array[offset+2]=block>>16&255}}return array};function Kmac(bits,padding,outputBits){Keccak.call(this,bits,padding,outputBits)}Kmac.prototype=new Keccak;Kmac.prototype.finalize=function(){this.encode(this.outputBits,true);return Keccak.prototype.finalize.call(this)};var f=function(s){var h,l,n,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,b0,b1,b2,b3,b4,b5,b6,b7,b8,b9,b10,b11,b12,b13,b14,b15,b16,b17,b18,b19,b20,b21,b22,b23,b24,b25,b26,b27,b28,b29,b30,b31,b32,b33,b34,b35,b36,b37,b38,b39,b40,b41,b42,b43,b44,b45,b46,b47,b48,b49;for(n=0;n<48;n+=2){c0=s[0]^s[10]^s[20]^s[30]^s[40];c1=s[1]^s[11]^s[21]^s[31]^s[41];c2=s[2]^s[12]^s[22]^s[32]^s[42];c3=s[3]^s[13]^s[23]^s[33]^s[43];c4=s[4]^s[14]^s[24]^s[34]^s[44];c5=s[5]^s[15]^s[25]^s[35]^s[45];c6=s[6]^s[16]^s[26]^s[36]^s[46];c7=s[7]^s[17]^s[27]^s[37]^s[47];c8=s[8]^s[18]^s[28]^s[38]^s[48];c9=s[9]^s[19]^s[29]^s[39]^s[49];h=c8^(c2<<1|c3>>>31);l=c9^(c3<<1|c2>>>31);s[0]^=h;s[1]^=l;s[10]^=h;s[11]^=l;s[20]^=h;s[21]^=l;s[30]^=h;s[31]^=l;s[40]^=h;s[41]^=l;h=c0^(c4<<1|c5>>>31);l=c1^(c5<<1|c4>>>31);s[2]^=h;s[3]^=l;s[12]^=h;s[13]^=l;s[22]^=h;s[23]^=l;s[32]^=h;s[33]^=l;s[42]^=h;s[43]^=l;h=c2^(c6<<1|c7>>>31);l=c3^(c7<<1|c6>>>31);s[4]^=h;s[5]^=l;s[14]^=h;s[15]^=l;s[24]^=h;s[25]^=l;s[34]^=h;s[35]^=l;s[44]^=h;s[45]^=l;h=c4^(c8<<1|c9>>>31);l=c5^(c9<<1|c8>>>31);s[6]^=h;s[7]^=l;s[16]^=h;s[17]^=l;s[26]^=h;s[27]^=l;s[36]^=h;s[37]^=l;s[46]^=h;s[47]^=l;h=c6^(c0<<1|c1>>>31);l=c7^(c1<<1|c0>>>31);s[8]^=h;s[9]^=l;s[18]^=h;s[19]^=l;s[28]^=h;s[29]^=l;s[38]^=h;s[39]^=l;s[48]^=h;s[49]^=l;b0=s[0];b1=s[1];b32=s[11]<<4|s[10]>>>28;b33=s[10]<<4|s[11]>>>28;b14=s[20]<<3|s[21]>>>29;b15=s[21]<<3|s[20]>>>29;b46=s[31]<<9|s[30]>>>23;b47=s[30]<<9|s[31]>>>23;b28=s[40]<<18|s[41]>>>14;b29=s[41]<<18|s[40]>>>14;b20=s[2]<<1|s[3]>>>31;b21=s[3]<<1|s[2]>>>31;b2=s[13]<<12|s[12]>>>20;b3=s[12]<<12|s[13]>>>20;b34=s[22]<<10|s[23]>>>22;b35=s[23]<<10|s[22]>>>22;b16=s[33]<<13|s[32]>>>19;b17=s[32]<<13|s[33]>>>19;b48=s[42]<<2|s[43]>>>30;b49=s[43]<<2|s[42]>>>30;b40=s[5]<<30|s[4]>>>2;b41=s[4]<<30|s[5]>>>2;b22=s[14]<<6|s[15]>>>26;b23=s[15]<<6|s[14]>>>26;b4=s[25]<<11|s[24]>>>21;b5=s[24]<<11|s[25]>>>21;b36=s[34]<<15|s[35]>>>17;b37=s[35]<<15|s[34]>>>17;b18=s[45]<<29|s[44]>>>3;b19=s[44]<<29|s[45]>>>3;b10=s[6]<<28|s[7]>>>4;b11=s[7]<<28|s[6]>>>4;b42=s[17]<<23|s[16]>>>9;b43=s[16]<<23|s[17]>>>9;b24=s[26]<<25|s[27]>>>7;b25=s[27]<<25|s[26]>>>7;b6=s[36]<<21|s[37]>>>11;b7=s[37]<<21|s[36]>>>11;b38=s[47]<<24|s[46]>>>8;b39=s[46]<<24|s[47]>>>8;b30=s[8]<<27|s[9]>>>5;b31=s[9]<<27|s[8]>>>5;b12=s[18]<<20|s[19]>>>12;b13=s[19]<<20|s[18]>>>12;b44=s[29]<<7|s[28]>>>25;b45=s[28]<<7|s[29]>>>25;b26=s[38]<<8|s[39]>>>24;b27=s[39]<<8|s[38]>>>24;b8=s[48]<<14|s[49]>>>18;b9=s[49]<<14|s[48]>>>18;s[0]=b0^~b2&b4;s[1]=b1^~b3&b5;s[10]=b10^~b12&b14;s[11]=b11^~b13&b15;s[20]=b20^~b22&b24;s[21]=b21^~b23&b25;s[30]=b30^~b32&b34;s[31]=b31^~b33&b35;s[40]=b40^~b42&b44;s[41]=b41^~b43&b45;s[2]=b2^~b4&b6;s[3]=b3^~b5&b7;s[12]=b12^~b14&b16;s[13]=b13^~b15&b17;s[22]=b22^~b24&b26;s[23]=b23^~b25&b27;s[32]=b32^~b34&b36;s[33]=b33^~b35&b37;s[42]=b42^~b44&b46;s[43]=b43^~b45&b47;s[4]=b4^~b6&b8;s[5]=b5^~b7&b9;s[14]=b14^~b16&b18;s[15]=b15^~b17&b19;s[24]=b24^~b26&b28;s[25]=b25^~b27&b29;s[34]=b34^~b36&b38;s[35]=b35^~b37&b39;s[44]=b44^~b46&b48;s[45]=b45^~b47&b49;s[6]=b6^~b8&b0;s[7]=b7^~b9&b1;s[16]=b16^~b18&b10;s[17]=b17^~b19&b11;s[26]=b26^~b28&b20;s[27]=b27^~b29&b21;s[36]=b36^~b38&b30;s[37]=b37^~b39&b31;s[46]=b46^~b48&b40;s[47]=b47^~b49&b41;s[8]=b8^~b0&b2;s[9]=b9^~b1&b3;s[18]=b18^~b10&b12;s[19]=b19^~b11&b13;s[28]=b28^~b20&b22;s[29]=b29^~b21&b23;s[38]=b38^~b30&b32;s[39]=b39^~b31&b33;s[48]=b48^~b40&b42;s[49]=b49^~b41&b43;s[0]^=RC[n];s[1]^=RC[n+1]}};if(COMMON_JS){module.exports=methods}else{for(i=0;i<methodNames.length;++i){root[methodNames[i]]=methods[methodNames[i]]}}})()})(sha3$1);var sha3Exports=sha3$1.exports;var sha3=getDefaultExportFromCjs(sha3Exports);const version$2="logger/5.7.0";let _permanentCensorErrors=false;let _censorErrors=false;const LogLevels={debug:1,default:2,info:2,warning:3,error:4,off:5};let _logLevel=LogLevels["default"];let _globalLogger=null;function _checkNormalize(){try{const missing=[];["NFD","NFC","NFKD","NFKC"].forEach(form=>{try{if("test".normalize(form)!=="test"){throw new Error("bad normalize")}}catch(error){missing.push(form)}});if(missing.length){throw new Error("missing "+missing.join(", "))}if(String.fromCharCode(233).normalize("NFD")!==String.fromCharCode(101,769)){throw new Error("broken implementation")}}catch(error){return error.message}return null}const _normalizeError=_checkNormalize();var LogLevel;(function(LogLevel){LogLevel["DEBUG"]="DEBUG";LogLevel["INFO"]="INFO";LogLevel["WARNING"]="WARNING";LogLevel["ERROR"]="ERROR";LogLevel["OFF"]="OFF"})(LogLevel||(LogLevel={}));var ErrorCode;(function(ErrorCode){ErrorCode["UNKNOWN_ERROR"]="UNKNOWN_ERROR";ErrorCode["NOT_IMPLEMENTED"]="NOT_IMPLEMENTED";ErrorCode["UNSUPPORTED_OPERATION"]="UNSUPPORTED_OPERATION";ErrorCode["NETWORK_ERROR"]="NETWORK_ERROR";ErrorCode["SERVER_ERROR"]="SERVER_ERROR";ErrorCode["TIMEOUT"]="TIMEOUT";ErrorCode["BUFFER_OVERRUN"]="BUFFER_OVERRUN";ErrorCode["NUMERIC_FAULT"]="NUMERIC_FAULT";ErrorCode["MISSING_NEW"]="MISSING_NEW";ErrorCode["INVALID_ARGUMENT"]="INVALID_ARGUMENT";ErrorCode["MISSING_ARGUMENT"]="MISSING_ARGUMENT";ErrorCode["UNEXPECTED_ARGUMENT"]="UNEXPECTED_ARGUMENT";ErrorCode["CALL_EXCEPTION"]="CALL_EXCEPTION";ErrorCode["INSUFFICIENT_FUNDS"]="INSUFFICIENT_FUNDS";ErrorCode["NONCE_EXPIRED"]="NONCE_EXPIRED";ErrorCode["REPLACEMENT_UNDERPRICED"]="REPLACEMENT_UNDERPRICED";ErrorCode["UNPREDICTABLE_GAS_LIMIT"]="UNPREDICTABLE_GAS_LIMIT";ErrorCode["TRANSACTION_REPLACED"]="TRANSACTION_REPLACED";ErrorCode["ACTION_REJECTED"]="ACTION_REJECTED"})(ErrorCode||(ErrorCode={}));const HEX="0123456789abcdef";class Logger{constructor(version){Object.defineProperty(this,"version",{enumerable:true,value:version,writable:false})}_log(logLevel,args){const level=logLevel.toLowerCase();if(LogLevels[level]==null){this.throwArgumentError("invalid log level name","logLevel",logLevel)}if(_logLevel>LogLevels[level]){return}console.log.apply(console,args)}debug(...args){this._log(Logger.levels.DEBUG,args)}info(...args){this._log(Logger.levels.INFO,args)}warn(...args){this._log(Logger.levels.WARNING,args)}makeError(message,code,params){if(_censorErrors){return this.makeError("censored error",code,{})}if(!code){code=Logger.errors.UNKNOWN_ERROR}if(!params){params={}}const messageDetails=[];Object.keys(params).forEach(key=>{const value=params[key];try{if(value instanceof Uint8Array){let hex="";for(let i=0;i<value.length;i++){hex+=HEX[value[i]>>4];hex+=HEX[value[i]&15]}messageDetails.push(key+"=Uint8Array(0x"+hex+")")}else{messageDetails.push(key+"="+JSON.stringify(value))}}catch(error){messageDetails.push(key+"="+JSON.stringify(params[key].toString()))}});messageDetails.push(`code=${code}`);messageDetails.push(`version=${this.version}`);const reason=message;let url="";switch(code){case ErrorCode.NUMERIC_FAULT:{url="NUMERIC_FAULT";const fault=message;switch(fault){case"overflow":case"underflow":case"division-by-zero":url+="-"+fault;break;case"negative-power":case"negative-width":url+="-unsupported";break;case"unbound-bitwise-result":url+="-unbound-result";break}break}case ErrorCode.CALL_EXCEPTION:case ErrorCode.INSUFFICIENT_FUNDS:case ErrorCode.MISSING_NEW:case ErrorCode.NONCE_EXPIRED:case ErrorCode.REPLACEMENT_UNDERPRICED:case ErrorCode.TRANSACTION_REPLACED:case ErrorCode.UNPREDICTABLE_GAS_LIMIT:url=code;break}if(url){message+=" [ See: https://links.ethers.org/v5-errors-"+url+" ]"}if(messageDetails.length){message+=" ("+messageDetails.join(", ")+")"}const error=new Error(message);error.reason=reason;error.code=code;Object.keys(params).forEach(function(key){error[key]=params[key]});return error}throwError(message,code,params){throw this.makeError(message,code,params)}throwArgumentError(message,name,value){return this.throwError(message,Logger.errors.INVALID_ARGUMENT,{argument:name,value:value})}assert(condition,message,code,params){if(!!condition){return}this.throwError(message,code,params)}assertArgument(condition,message,name,value){if(!!condition){return}this.throwArgumentError(message,name,value)}checkNormalize(message){if(_normalizeError){this.throwError("platform missing String.prototype.normalize",Logger.errors.UNSUPPORTED_OPERATION,{operation:"String.prototype.normalize",form:_normalizeError})}}checkSafeUint53(value,message){if(typeof value!=="number"){return}if(message==null){message="value not safe"}if(value<0||value>=9007199254740991){this.throwError(message,Logger.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"out-of-safe-range",value:value})}if(value%1){this.throwError(message,Logger.errors.NUMERIC_FAULT,{operation:"checkSafeInteger",fault:"non-integer",value:value})}}checkArgumentCount(count,expectedCount,message){if(message){message=": "+message}else{message=""}if(count<expectedCount){this.throwError("missing argument"+message,Logger.errors.MISSING_ARGUMENT,{count:count,expectedCount:expectedCount})}if(count>expectedCount){this.throwError("too many arguments"+message,Logger.errors.UNEXPECTED_ARGUMENT,{count:count,expectedCount:expectedCount})}}checkNew(target,kind){if(target===Object||target==null){this.throwError("missing new",Logger.errors.MISSING_NEW,{name:kind.name})}}checkAbstract(target,kind){if(target===kind){this.throwError("cannot instantiate abstract class "+JSON.stringify(kind.name)+" directly; use a sub-class",Logger.errors.UNSUPPORTED_OPERATION,{name:target.name,operation:"new"})}else if(target===Object||target==null){this.throwError("missing new",Logger.errors.MISSING_NEW,{name:kind.name})}}static globalLogger(){if(!_globalLogger){_globalLogger=new Logger(version$2)}return _globalLogger}static setCensorship(censorship,permanent){if(!censorship&&permanent){this.globalLogger().throwError("cannot permanently disable censorship",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}if(_permanentCensorErrors){if(!censorship){return}this.globalLogger().throwError("error censorship permanent",Logger.errors.UNSUPPORTED_OPERATION,{operation:"setCensorship"})}_censorErrors=!!censorship;_permanentCensorErrors=!!permanent}static setLogLevel(logLevel){const level=LogLevels[logLevel.toLowerCase()];if(level==null){Logger.globalLogger().warn("invalid log level - "+logLevel);return}_logLevel=level}static from(version){return new Logger(version)}}Logger.errors=ErrorCode;Logger.levels=LogLevel;const version$1="bytes/5.7.0";const logger=new Logger(version$1);function isHexable(value){return!!value.toHexString}function addSlice(array){if(array.slice){return array}array.slice=function(){const args=Array.prototype.slice.call(arguments);return addSlice(new Uint8Array(Array.prototype.slice.apply(array,args)))};return array}function isInteger(value){return typeof value==="number"&&value==value&&value%1===0}function isBytes(value){if(value==null){return false}if(value.constructor===Uint8Array){return true}if(typeof value==="string"){return false}if(!isInteger(value.length)||value.length<0){return false}for(let i=0;i<value.length;i++){const v=value[i];if(!isInteger(v)||v<0||v>=256){return false}}return true}function arrayify(value,options){if(!options){options={}}if(typeof value==="number"){logger.checkSafeUint53(value,"invalid arrayify value");const result=[];while(value){result.unshift(value&255);value=parseInt(String(value/256))}if(result.length===0){result.push(0)}return addSlice(new Uint8Array(result))}if(options.allowMissingPrefix&&typeof value==="string"&&value.substring(0,2)!=="0x"){value="0x"+value}if(isHexable(value)){value=value.toHexString()}if(isHexString$1(value)){let hex=value.substring(2);if(hex.length%2){if(options.hexPad==="left"){hex="0"+hex}else if(options.hexPad==="right"){hex+="0"}else{logger.throwArgumentError("hex data is odd-length","value",value)}}const result=[];for(let i=0;i<hex.length;i+=2){result.push(parseInt(hex.substring(i,i+2),16))}return addSlice(new Uint8Array(result))}if(isBytes(value)){return addSlice(new Uint8Array(value))}return logger.throwArgumentError("invalid arrayify value","value",value)}function isHexString$1(value,length){if(typeof value!=="string"||!value.match(/^0x[0-9A-Fa-f]*$/)){return false}if(length&&value.length!==2+2*length){return false}return true}const HexCharacters$1="0123456789abcdef";function hexlify$1(value,options){if(!options){options={}}if(typeof value==="number"){logger.checkSafeUint53(value,"invalid hexlify value");let hex="";while(value){hex=HexCharacters$1[value&15]+hex;value=Math.floor(value/16)}if(hex.length){if(hex.length%2){hex="0"+hex}return"0x"+hex}return"0x00"}if(typeof value==="bigint"){value=value.toString(16);if(value.length%2){return"0x0"+value}return"0x"+value}if(options.allowMissingPrefix&&typeof value==="string"&&value.substring(0,2)!=="0x"){value="0x"+value}if(isHexable(value)){return value.toHexString()}if(isHexString$1(value)){if(value.length%2){if(options.hexPad==="left"){value="0x0"+value.substring(2)}else if(options.hexPad==="right"){value+="0"}else{logger.throwArgumentError("hex data is odd-length","value",value)}}return value.toLowerCase()}if(isBytes(value)){let result="0x";for(let i=0;i<value.length;i++){let v=value[i];result+=HexCharacters$1[(v&240)>>4]+HexCharacters$1[v&15]}return result}return logger.throwArgumentError("invalid hexlify value","value",value)}function hexConcat(items){let result="0x";items.forEach(item=>{result+=hexlify$1(item).substring(2)});return result}function keccak256$1(data){return"0x"+sha3.keccak_256(arrayify(data))}const TESTNET_FLOW_ADDRESS="0x8873cc79c5b3b5666535C825205C9a128B1D75F1";const DEFAULT_CHUNK_SIZE=256;const DEFAULT_SEGMENT_MAX_CHUNKS=1024;const DEFAULT_SEGMENT_SIZE=DEFAULT_CHUNK_SIZE*DEFAULT_SEGMENT_MAX_CHUNKS;const EMPTY_CHUNK=new Uint8Array(DEFAULT_CHUNK_SIZE);const EMPTY_CHUNK_HASH=keccak256$1(EMPTY_CHUNK);const SMALL_FILE_SIZE_THRESHOLD=256*1024;const ZERO_HASH="0x0000000000000000000000000000000000000000000000000000000000000000";const version="6.13.0";function checkType(value,type,name){const types=type.split("|").map(t=>t.trim());for(let i=0;i<types.length;i++){switch(type){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof value===type){return}}}const error=new Error(`invalid value for type ${type}`);error.code="INVALID_ARGUMENT";error.argument=`value.${name}`;error.value=value;throw error}async function resolveProperties(value){const keys=Object.keys(value);const results=await Promise.all(keys.map(k=>Promise.resolve(value[k])));return results.reduce((accum,v,index)=>{accum[keys[index]]=v;return accum},{})}function defineProperties(target,values,types){for(let key in values){let value=values[key];const type=types?types[key]:null;if(type){checkType(value,type,key)}Object.defineProperty(target,key,{enumerable:true,value:value,writable:false})}}function stringify(value){if(value==null){return"null"}if(Array.isArray(value)){return"[ "+value.map(stringify).join(", ")+" ]"}if(value instanceof Uint8Array){const HEX="0123456789abcdef";let result="0x";for(let i=0;i<value.length;i++){result+=HEX[value[i]>>4];result+=HEX[value[i]&15]}return result}if(typeof value==="object"&&typeof value.toJSON==="function"){return stringify(value.toJSON())}switch(typeof value){case"boolean":case"symbol":return value.toString();case"bigint":return BigInt(value).toString();case"number":return value.toString();case"string":return JSON.stringify(value);case"object":{const keys=Object.keys(value);keys.sort();return"{ "+keys.map(k=>`${stringify(k)}: ${stringify(value[k])}`).join(", ")+" }"}}return`[ COULD NOT SERIALIZE ]`}function isError(error,code){return error&&error.code===code}function isCallException(error){return isError(error,"CALL_EXCEPTION")}function makeError(message,code,info){let shortMessage=message;{const details=[];if(info){if("message"in info||"code"in info||"name"in info){throw new Error(`value will overwrite populated values: ${stringify(info)}`)}for(const key in info){if(key==="shortMessage"){continue}const value=info[key];details.push(key+"="+stringify(value))}}details.push(`code=${code}`);details.push(`version=${version}`);if(details.length){message+=" ("+details.join(", ")+")"}}let error;switch(code){case"INVALID_ARGUMENT":error=new TypeError(message);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":error=new RangeError(message);break;default:error=new Error(message)}defineProperties(error,{code:code});if(info){Object.assign(error,info)}if(error.shortMessage==null){defineProperties(error,{shortMessage:shortMessage})}return error}function assert(check,message,code,info){if(!check){throw makeError(message,code,info)}}function assertArgument(check,message,name,value){assert(check,message,"INVALID_ARGUMENT",{argument:name,value:value})}function assertArgumentCount(count,expectedCount,message){if(message==null){message=""}if(message){message=": "+message}assert(count>=expectedCount,"missing arguemnt"+message,"MISSING_ARGUMENT",{count:count,expectedCount:expectedCount});assert(count<=expectedCount,"too many arguments"+message,"UNEXPECTED_ARGUMENT",{count:count,expectedCount:expectedCount})}const _normalizeForms=["NFD","NFC","NFKD","NFKC"].reduce((accum,form)=>{try{if("test".normalize(form)!=="test"){throw new Error("bad")}if(form==="NFD"){const check=String.fromCharCode(233).normalize("NFD");const expected=String.fromCharCode(101,769);if(check!==expected){throw new Error("broken")}}accum.push(form)}catch(error){}return accum},[]);function assertNormalize(form){assert(_normalizeForms.indexOf(form)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:form}})}function assertPrivate(givenGuard,guard,className){if(className==null){className=""}if(givenGuard!==guard){let method=className,operation="new";if(className){method+=".";operation+=" "+className}assert(false,`private constructor; use ${method}from* methods`,"UNSUPPORTED_OPERATION",{operation:operation})}}function _getBytes(value,name,copy){if(value instanceof Uint8Array){if(copy){return new Uint8Array(value)}return value}if(typeof value==="string"&&value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const result=new Uint8Array((value.length-2)/2);let offset=2;for(let i=0;i<result.length;i++){result[i]=parseInt(value.substring(offset,offset+2),16);offset+=2}return result}assertArgument(false,"invalid BytesLike value",name||"value",value)}function getBytes(value,name){return _getBytes(value,name,false)}function getBytesCopy(value,name){return _getBytes(value,name,true)}function isHexString(value,length){if(typeof value!=="string"||!value.match(/^0x[0-9A-Fa-f]*$/)){return false}if(typeof length==="number"&&value.length!==2+2*length){return false}if(length===true&&value.length%2!==0){return false}return true}function isBytesLike(value){return isHexString(value,true)||value instanceof Uint8Array}const HexCharacters="0123456789abcdef";function hexlify(data){const bytes=getBytes(data);let result="0x";for(let i=0;i<bytes.length;i++){const v=bytes[i];result+=HexCharacters[(v&240)>>4]+HexCharacters[v&15]}return result}function concat(datas){return"0x"+datas.map(d=>hexlify(d).substring(2)).join("")}function dataSlice(data,start,end){const bytes=getBytes(data);if(end!=null&&end>bytes.length){assert(false,"cannot slice beyond data bounds","BUFFER_OVERRUN",{buffer:bytes,length:bytes.length,offset:end})}return hexlify(bytes.slice(start==null?0:start,end==null?bytes.length:end))}function zeroPad(data,length,left){const bytes=getBytes(data);assert(length>=bytes.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(bytes),length:length,offset:length+1});const result=new Uint8Array(length);result.fill(0);if(left){result.set(bytes,length-bytes.length)}else{result.set(bytes,0)}return hexlify(result)}function zeroPadValue(data,length){return zeroPad(data,length,true)}function zeroPadBytes(data,length){return zeroPad(data,length,false)}const BN_0$4=BigInt(0);const BN_1$1=BigInt(1);const maxValue=9007199254740991;function fromTwos(_value,_width){const value=getUint(_value,"value");const width=BigInt(getNumber(_width,"width"));assert(value>>width===BN_0$4,"overflow","NUMERIC_FAULT",{operation:"fromTwos",fault:"overflow",value:_value});if(value>>width-BN_1$1){const mask=(BN_1$1<<width)-BN_1$1;return-((~value&mask)+BN_1$1)}return value}function toTwos(_value,_width){let value=getBigInt(_value,"value");const width=BigInt(getNumber(_width,"width"));const limit=BN_1$1<<width-BN_1$1;if(value<BN_0$4){value=-value;assert(value<=limit,"too low","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:_value});const mask=(BN_1$1<<width)-BN_1$1;return(~value&mask)+BN_1$1}else{assert(value<limit,"too high","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:_value})}return value}function mask(_value,_bits){const value=getUint(_value,"value");const bits=BigInt(getNumber(_bits,"bits"));return value&(BN_1$1<<bits)-BN_1$1}function getBigInt(value,name){switch(typeof value){case"bigint":return value;case"number":assertArgument(Number.isInteger(value),"underflow",name||"value",value);assertArgument(value>=-maxValue&&value<=maxValue,"overflow",name||"value",value);return BigInt(value);case"string":try{if(value===""){throw new Error("empty string")}if(value[0]==="-"&&value[1]!=="-"){return-BigInt(value.substring(1))}return BigInt(value)}catch(e){assertArgument(false,`invalid BigNumberish string: ${e.message}`,name||"value",value)}}assertArgument(false,"invalid BigNumberish value",name||"value",value)}function getUint(value,name){const result=getBigInt(value,name);assert(result>=BN_0$4,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:value});return result}const Nibbles="0123456789abcdef";function toBigInt(value){if(value instanceof Uint8Array){let result="0x0";for(const v of value){result+=Nibbles[v>>4];result+=Nibbles[v&15]}return BigInt(result)}return getBigInt(value)}function getNumber(value,name){switch(typeof value){case"bigint":assertArgument(value>=-maxValue&&value<=maxValue,"overflow",name||"value",value);return Number(value);case"number":assertArgument(Number.isInteger(value),"underflow",name||"value",value);assertArgument(value>=-maxValue&&value<=maxValue,"overflow",name||"value",value);return value;case"string":try{if(value===""){throw new Error("empty string")}return getNumber(BigInt(value),name)}catch(e){assertArgument(false,`invalid numeric string: ${e.message}`,name||"value",value)}}assertArgument(false,"invalid numeric value",name||"value",value)}function toNumber(value){return getNumber(toBigInt(value))}function toBeHex(_value,_width){const value=getUint(_value,"value");let result=value.toString(16);if(_width==null){if(result.length%2){result="0"+result}}else{const width=getNumber(_width,"width");assert(width*2>=result.length,`value exceeds width (${width} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:_value});while(result.length<width*2){result="0"+result}}return"0x"+result}function toBeArray(_value){const value=getUint(_value,"value");if(value===BN_0$4){return new Uint8Array([])}let hex=value.toString(16);if(hex.length%2){hex="0"+hex}const result=new Uint8Array(hex.length/2);for(let i=0;i<result.length;i++){const offset=i*2;result[i]=parseInt(hex.substring(offset,offset+2),16)}return result}function decodeBase64(textData){textData=atob(textData);const data=new Uint8Array(textData.length);for(let i=0;i<textData.length;i++){data[i]=textData.charCodeAt(i)}return getBytes(data)}function encodeBase64(_data){const data=getBytes(_data);let textData="";for(let i=0;i<data.length;i++){textData+=String.fromCharCode(data[i])}return btoa(textData)}class EventPayload{filter;emitter;#listener;constructor(emitter,listener,filter){this.#listener=listener;defineProperties(this,{emitter:emitter,filter:filter})}async removeListener(){if(this.#listener==null){return}await this.emitter.off(this.filter,this.#listener)}}function errorFunc(reason,offset,bytes,output,badCodepoint){assertArgument(false,`invalid codepoint at offset ${offset}; ${reason}`,"bytes",bytes)}function ignoreFunc(reason,offset,bytes,output,badCodepoint){if(reason==="BAD_PREFIX"||reason==="UNEXPECTED_CONTINUE"){let i=0;for(let o=offset+1;o<bytes.length;o++){if(bytes[o]>>6!==2){break}i++}return i}if(reason==="OVERRUN"){return bytes.length-offset-1}return 0}function replaceFunc(reason,offset,bytes,output,badCodepoint){if(reason==="OVERLONG"){assertArgument(typeof badCodepoint==="number","invalid bad code point for replacement","badCodepoint",badCodepoint);output.push(badCodepoint);return 0}output.push(65533);return ignoreFunc(reason,offset,bytes)}const Utf8ErrorFuncs=Object.freeze({error:errorFunc,ignore:ignoreFunc,replace:replaceFunc});function getUtf8CodePoints(_bytes,onError){if(onError==null){onError=Utf8ErrorFuncs.error}const bytes=getBytes(_bytes,"bytes");const result=[];let i=0;while(i<bytes.length){const c=bytes[i++];if(c>>7===0){result.push(c);continue}let extraLength=null;let overlongMask=null;if((c&224)===192){extraLength=1;overlongMask=127}else if((c&240)===224){extraLength=2;overlongMask=2047}else if((c&248)===240){extraLength=3;overlongMask=65535}else{if((c&192)===128){i+=onError("UNEXPECTED_CONTINUE",i-1,bytes,result)}else{i+=onError("BAD_PREFIX",i-1,bytes,result)}continue}if(i-1+extraLength>=bytes.length){i+=onError("OVERRUN",i-1,bytes,result);continue}let res=c&(1<<8-extraLength-1)-1;for(let j=0;j<extraLength;j++){let nextChar=bytes[i];if((nextChar&192)!=128){i+=onError("MISSING_CONTINUE",i,bytes,result);res=null;break}res=res<<6|nextChar&63;i++}if(res===null){continue}if(res>1114111){i+=onError("OUT_OF_RANGE",i-1-extraLength,bytes,result,res);continue}if(res>=55296&&res<=57343){i+=onError("UTF16_SURROGATE",i-1-extraLength,bytes,result,res);continue}if(res<=overlongMask){i+=onError("OVERLONG",i-1-extraLength,bytes,result,res);continue}result.push(res)}return result}function toUtf8Bytes(str,form){assertArgument(typeof str==="string","invalid string value","str",str);if(form!=null){assertNormalize(form);str=str.normalize(form)}let result=[];for(let i=0;i<str.length;i++){const c=str.charCodeAt(i);if(c<128){result.push(c)}else if(c<2048){result.push(c>>6|192);result.push(c&63|128)}else if((c&64512)==55296){i++;const c2=str.charCodeAt(i);assertArgument(i<str.length&&(c2&64512)===56320,"invalid surrogate pair","str",str);const pair=65536+((c&1023)<<10)+(c2&1023);result.push(pair>>18|240);result.push(pair>>12&63|128);result.push(pair>>6&63|128);result.push(pair&63|128)}else{result.push(c>>12|224);result.push(c>>6&63|128);result.push(c&63|128)}}return new Uint8Array(result)}function _toUtf8String(codePoints){return codePoints.map(codePoint=>{if(codePoint<=65535){return String.fromCharCode(codePoint)}codePoint-=65536;return String.fromCharCode((codePoint>>10&1023)+55296,(codePoint&1023)+56320)}).join("")}function toUtf8String(bytes,onError){return _toUtf8String(getUtf8CodePoints(bytes,onError))}function arrayifyInteger(value){const result=[];while(value){result.unshift(value&255);value>>=8}return result}function _encode(object){if(Array.isArray(object)){let payload=[];object.forEach(function(child){payload=payload.concat(_encode(child))});if(payload.length<=55){payload.unshift(192+payload.length);return payload}const length=arrayifyInteger(payload.length);length.unshift(247+length.length);return length.concat(payload)}const data=Array.prototype.slice.call(getBytes(object,"object"));if(data.length===1&&data[0]<=127){return data}else if(data.length<=55){data.unshift(128+data.length);return data}const length=arrayifyInteger(data.length);length.unshift(183+length.length);return length.concat(data)}const nibbles="0123456789abcdef";function encodeRlp(object){let result="0x";for(const v of _encode(object)){result+=nibbles[v>>4];result+=nibbles[v&15]}return result}const WordSize=32;const Padding=new Uint8Array(WordSize);const passProperties$1=["then"];const _guard$1={};const resultNames=new WeakMap;function getNames(result){return resultNames.get(result)}function setNames(result,names){resultNames.set(result,names)}function throwError(name,error){const wrapped=new Error(`deferred error during ABI decoding triggered accessing ${name}`);wrapped.error=error;throw wrapped}function toObject(names,items,deep){if(names.indexOf(null)>=0){return items.map((item,index)=>{if(item instanceof Result){return toObject(getNames(item),item,deep)}return item})}return names.reduce((accum,name,index)=>{let item=items.getValue(name);if(!(name in accum)){if(deep&&item instanceof Result){item=toObject(getNames(item),item,deep)}accum[name]=item}return accum},{})}class Result extends Array{#names;constructor(...args){const guard=args[0];let items=args[1];let names=(args[2]||[]).slice();let wrap=true;if(guard!==_guard$1){items=args;names=[];wrap=false}super(items.length);items.forEach((item,index)=>{this[index]=item});const nameCounts=names.reduce((accum,name)=>{if(typeof name==="string"){accum.set(name,(accum.get(name)||0)+1)}return accum},new Map);setNames(this,Object.freeze(items.map((item,index)=>{const name=names[index];if(name!=null&&nameCounts.get(name)===1){return name}return null})));this.#names=[];if(this.#names==null){void this.#names}if(!wrap){return}Object.freeze(this);const proxy=new Proxy(this,{get:(target,prop,receiver)=>{if(typeof prop==="string"){if(prop.match(/^[0-9]+$/)){const index=getNumber(prop,"%index");if(index<0||index>=this.length){throw new RangeError("out of result range")}const item=target[index];if(item instanceof Error){throwError(`index ${index}`,item)}return item}if(passProperties$1.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}const value=target[prop];if(value instanceof Function){return function(...args){return value.apply(this===receiver?target:this,args)}}else if(!(prop in target)){return target.getValue.apply(this===receiver?target:this,[prop])}}return Reflect.get(target,prop,receiver)}});setNames(proxy,getNames(this));return proxy}toArray(deep){const result=[];this.forEach((item,index)=>{if(item instanceof Error){throwError(`index ${index}`,item)}if(deep&&item instanceof Result){item=item.toArray(deep)}result.push(item)});return result}toObject(deep){const names=getNames(this);return names.reduce((accum,name,index)=>{assert(name!=null,`value at index ${index} unnamed`,"UNSUPPORTED_OPERATION",{operation:"toObject()"});return toObject(names,this,deep)},{})}slice(start,end){if(start==null){start=0}if(start<0){start+=this.length;if(start<0){start=0}}if(end==null){end=this.length}if(end<0){end+=this.length;if(end<0){end=0}}if(end>this.length){end=this.length}const _names=getNames(this);const result=[],names=[];for(let i=start;i<end;i++){result.push(this[i]);names.push(_names[i])}return new Result(_guard$1,result,names)}filter(callback,thisArg){const _names=getNames(this);const result=[],names=[];for(let i=0;i<this.length;i++){const item=this[i];if(item instanceof Error){throwError(`index ${i}`,item)}if(callback.call(thisArg,item,i,this)){result.push(item);names.push(_names[i])}}return new Result(_guard$1,result,names)}map(callback,thisArg){const result=[];for(let i=0;i<this.length;i++){const item=this[i];if(item instanceof Error){throwError(`index ${i}`,item)}result.push(callback.call(thisArg,item,i,this))}return result}getValue(name){const index=getNames(this).indexOf(name);if(index===-1){return undefined}const value=this[index];if(value instanceof Error){throwError(`property ${JSON.stringify(name)}`,value.error)}return value}static fromItems(items,keys){return new Result(_guard$1,items,keys)}}function getValue(value){let bytes=toBeArray(value);assert(bytes.length<=WordSize,"value out-of-bounds","BUFFER_OVERRUN",{buffer:bytes,length:WordSize,offset:bytes.length});if(bytes.length!==WordSize){bytes=getBytesCopy(concat([Padding.slice(bytes.length%WordSize),bytes]))}return bytes}class Coder{name;type;localName;dynamic;constructor(name,type,localName,dynamic){defineProperties(this,{name:name,type:type,localName:localName,dynamic:dynamic},{name:"string",type:"string",localName:"string",dynamic:"boolean"})}_throwError(message,value){assertArgument(false,message,this.localName,value)}}class Writer{#data;#dataLength;constructor(){this.#data=[];this.#dataLength=0}get data(){return concat(this.#data)}get length(){return this.#dataLength}#writeData(data){this.#data.push(data);this.#dataLength+=data.length;return data.length}appendWriter(writer){return this.#writeData(getBytesCopy(writer.data))}writeBytes(value){let bytes=getBytesCopy(value);const paddingOffset=bytes.length%WordSize;if(paddingOffset){bytes=getBytesCopy(concat([bytes,Padding.slice(paddingOffset)]))}return this.#writeData(bytes)}writeValue(value){return this.#writeData(getValue(value))}writeUpdatableValue(){const offset=this.#data.length;this.#data.push(Padding);this.#dataLength+=WordSize;return value=>{this.#data[offset]=getValue(value)}}}class Reader{allowLoose;#data;#offset;#bytesRead;#parent;#maxInflation;constructor(data,allowLoose,maxInflation){defineProperties(this,{allowLoose:!!allowLoose});this.#data=getBytesCopy(data);this.#bytesRead=0;this.#parent=null;this.#maxInflation=maxInflation!=null?maxInflation:1024;this.#offset=0}get data(){return hexlify(this.#data)}get dataLength(){return this.#data.length}get consumed(){return this.#offset}get bytes(){return new Uint8Array(this.#data)}#incrementBytesRead(count){if(this.#parent){return this.#parent.#incrementBytesRead(count)}this.#bytesRead+=count;assert(this.#maxInflation<1||this.#bytesRead<=this.#maxInflation*this.dataLength,`compressed ABI data exceeds inflation ratio of ${this.#maxInflation} ( see: https:/\/github.com/ethers-io/ethers.js/issues/4537 )`,"BUFFER_OVERRUN",{buffer:getBytesCopy(this.#data),offset:this.#offset,length:count,info:{bytesRead:this.#bytesRead,dataLength:this.dataLength}})}#peekBytes(offset,length,loose){let alignedLength=Math.ceil(length/WordSize)*WordSize;if(this.#offset+alignedLength>this.#data.length){if(this.allowLoose&&loose&&this.#offset+length<=this.#data.length){alignedLength=length}else{assert(false,"data out-of-bounds","BUFFER_OVERRUN",{buffer:getBytesCopy(this.#data),length:this.#data.length,offset:this.#offset+alignedLength})}}return this.#data.slice(this.#offset,this.#offset+alignedLength)}subReader(offset){const reader=new Reader(this.#data.slice(this.#offset+offset),this.allowLoose,this.#maxInflation);reader.#parent=this;return reader}readBytes(length,loose){let bytes=this.#peekBytes(0,length,!!loose);this.#incrementBytesRead(length);this.#offset+=bytes.length;return bytes.slice(0,length)}readValue(){return toBigInt(this.readBytes(WordSize))}readIndex(){return toNumber(this.readBytes(WordSize))}}function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bytes(b,...lengths){if(!(b instanceof Uint8Array))throw new Error("Expected Uint8Array");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`)}function exists(instance,checkFinished=true){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min){throw new Error(`digestInto() expects output buffer of length at least ${min}`)}}const u8a=a=>a instanceof Uint8Array;const u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4));const isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes(str){if(typeof str!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){if(typeof data==="string")data=utf8ToBytes(data);if(!u8a(data))throw new Error(`expected Uint8Array, got ${typeof data}`);return data}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest();const tmp=hashCons();hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=()=>hashCons();return hashC}const U32_MASK64=BigInt(2**32-1);const _32n=BigInt(32);function fromBig(n,le=false){if(le)return{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)};return{h:Number(n>>_32n&U32_MASK64)|0,l:Number(n&U32_MASK64)|0}}function split(lst,le=false){let Ah=new Uint32Array(lst.length);let Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const rotlSH=(h,l,s)=>h<<s|l>>>32-s;const rotlSL=(h,l,s)=>l<<s|h>>>32-s;const rotlBH=(h,l,s)=>l<<s-32|h>>>64-s;const rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;const[SHA3_PI,SHA3_ROTL,_SHA3_IOTA]=[[],[],[]];const _0n=BigInt(0);const _1n=BigInt(1);const _2n=BigInt(2);const _7n=BigInt(7);const _256n=BigInt(256);const _0x71n=BigInt(113);for(let round=0,R=_1n,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5];SHA3_PI.push(2*(5*y+x));SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n;for(let j=0;j<7;j++){R=(R<<_1n^(R>>_7n)*_0x71n)%_256n;if(R&_2n)t^=_1n<<(_1n<<BigInt(j))-_1n}_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=split(_SHA3_IOTA,true);const rotlH=(h,l,s)=>s>32?rotlBH(h,l,s):rotlSH(h,l,s);const rotlL=(h,l,s)=>s>32?rotlBL(h,l,s):rotlSL(h,l,s);function keccakP(s,rounds=24){const B=new Uint32Array(5*2);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10;const idx0=(x+2)%10;const B0=B[idx0];const B1=B[idx0+1];const Th=rotlH(B0,B1,1)^B[idx1];const Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10){s[x+y]^=Th;s[x+y+1]^=Tl}}let curH=s[2];let curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t];const Th=rotlH(curH,curL,shift);const Tl=rotlL(curH,curL,shift);const PI=SHA3_PI[t];curH=s[PI];curL=s[PI+1];s[PI]=Th;s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round];s[1]^=SHA3_IOTA_L[round]}B.fill(0)}class Keccak extends Hash{constructor(blockLen,suffix,outputLen,enableXOF=false,rounds=24){super();this.blockLen=blockLen;this.suffix=suffix;this.outputLen=outputLen;this.enableXOF=enableXOF;this.rounds=rounds;this.pos=0;this.posOut=0;this.finished=false;this.destroyed=false;number(outputLen);if(0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200);this.state32=u32(this.state)}keccak(){keccakP(this.state32,this.rounds);this.posOut=0;this.pos=0}update(data){exists(this);const{blockLen,state}=this;data=toBytes(data);const len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];if(this.pos===blockLen)this.keccak()}return this}finish(){if(this.finished)return;this.finished=true;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix;if((suffix&128)!==0&&pos===blockLen-1)this.keccak();state[blockLen-1]^=128;this.keccak()}writeInto(out){exists(this,false);bytes(out);this.finish();const bufferOut=this.state;const{blockLen}=this;for(let pos=0,len=out.length;pos<len;){if(this.posOut>=blockLen)this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos);this.posOut+=take;pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){number(bytes);return this.xofInto(new Uint8Array(bytes))}digestInto(out){output(out,this);if(this.finished)throw new Error("digest() was already called");this.writeInto(out);this.destroy();return out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=true;this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds));to.state32.set(this.state32);to.pos=this.pos;to.posOut=this.posOut;to.finished=this.finished;to.rounds=rounds;to.suffix=suffix;to.outputLen=outputLen;to.enableXOF=enableXOF;to.destroyed=this.destroyed;return to}}const gen=(suffix,blockLen,outputLen)=>wrapConstructor(()=>new Keccak(blockLen,suffix,outputLen));const keccak_256=gen(1,136,256/8);let locked=false;const _keccak256=function(data){return keccak_256(data)};let __keccak256=_keccak256;function keccak256(_data){const data=getBytes(_data,"data");return hexlify(__keccak256(data))}keccak256._=_keccak256;keccak256.lock=function(){locked=true};keccak256.register=function(func){if(locked){throw new TypeError("keccak256 is locked")}__keccak256=func};Object.freeze(keccak256);const BN_0$3=BigInt(0);const BN_36=BigInt(36);function getChecksumAddress(address){address=address.toLowerCase();const chars=address.substring(2).split("");const expanded=new Uint8Array(40);for(let i=0;i<40;i++){expanded[i]=chars[i].charCodeAt(0)}const hashed=getBytes(keccak256(expanded));for(let i=0;i<40;i+=2){if(hashed[i>>1]>>4>=8){chars[i]=chars[i].toUpperCase()}if((hashed[i>>1]&15)>=8){chars[i+1]=chars[i+1].toUpperCase()}}return"0x"+chars.join("")}const ibanLookup={};for(let i=0;i<10;i++){ibanLookup[String(i)]=String(i)}for(let i=0;i<26;i++){ibanLookup[String.fromCharCode(65+i)]=String(10+i)}const safeDigits=15;function ibanChecksum(address){address=address.toUpperCase();address=address.substring(4)+address.substring(0,2)+"00";let expanded=address.split("").map(c=>{return ibanLookup[c]}).join("");while(expanded.length>=safeDigits){let block=expanded.substring(0,safeDigits);expanded=parseInt(block,10)%97+expanded.substring(block.length)}let checksum=String(98-parseInt(expanded,10)%97);while(checksum.length<2){checksum="0"+checksum}return checksum}const Base36=function(){const result={};for(let i=0;i<36;i++){const key="0123456789abcdefghijklmnopqrstuvwxyz"[i];result[key]=BigInt(i)}return result}();function fromBase36(value){value=value.toLowerCase();let result=BN_0$3;for(let i=0;i<value.length;i++){result=result*BN_36+Base36[value[i]]}return result}function getAddress(address){assertArgument(typeof address==="string","invalid address","address",address);if(address.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!address.startsWith("0x")){address="0x"+address}const result=getChecksumAddress(address);assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||result===address,"bad address checksum","address",address);return result}if(address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){assertArgument(address.substring(2,4)===ibanChecksum(address),"bad icap checksum","address",address);let result=fromBase36(address.substring(4)).toString(16);while(result.length<40){result="0"+result}return getChecksumAddress("0x"+result)}assertArgument(false,"invalid address","address",address)}function getCreateAddress(tx){const from=getAddress(tx.from);const nonce=getBigInt(tx.nonce,"tx.nonce");let nonceHex=nonce.toString(16);if(nonceHex==="0"){nonceHex="0x"}else if(nonceHex.length%2){nonceHex="0x0"+nonceHex}else{nonceHex="0x"+nonceHex}return getAddress(dataSlice(keccak256(encodeRlp([from,nonceHex])),12))}function isAddressable(value){return value&&typeof value.getAddress==="function"}async function checkAddress(target,promise){const result=await promise;if(result==null||result==="0x0000000000000000000000000000000000000000"){assert(typeof target!=="string","unconfigured name","UNCONFIGURED_NAME",{value:target});assertArgument(false,"invalid AddressLike value; did not resolve to a value address","target",target)}return getAddress(result)}function resolveAddress(target,resolver){if(typeof target==="string"){if(target.match(/^0x[0-9a-f]{40}$/i)){return getAddress(target)}assert(resolver!=null,"ENS resolution requires a provider","UNSUPPORTED_OPERATION",{operation:"resolveName"});return checkAddress(target,resolver.resolveName(target))}else if(isAddressable(target)){return checkAddress(target,target.getAddress())}else if(target&&typeof target.then==="function"){return checkAddress(target,target)}assertArgument(false,"unsupported addressable value","target",target)}const _gaurd={};function n(value,width){let signed=false;if(width<0){signed=true;width*=-1}return new Typed(_gaurd,`${signed?"":"u"}int${width}`,value,{signed:signed,width:width})}function b(value,size){return new Typed(_gaurd,`bytes${size?size:""}`,value,{size:size})}const _typedSymbol=Symbol.for("_ethers_typed");class Typed{type;value;#options;_typedSymbol;constructor(gaurd,type,value,options){if(options==null){options=null}assertPrivate(_gaurd,gaurd,"Typed");defineProperties(this,{_typedSymbol:_typedSymbol,type:type,value:value});this.#options=options;this.format()}format(){if(this.type==="array"){throw new Error("")}else if(this.type==="dynamicArray"){throw new Error("")}else if(this.type==="tuple"){return`tuple(${this.value.map(v=>v.format()).join(",")})`}return this.type}defaultValue(){return 0}minValue(){return 0}maxValue(){return 0}isBigInt(){return!!this.type.match(/^u?int[0-9]+$/)}isData(){return this.type.startsWith("bytes")}isString(){return this.type==="string"}get tupleName(){if(this.type!=="tuple"){throw TypeError("not a tuple")}return this.#options}get arrayLength(){if(this.type!=="array"){throw TypeError("not an array")}if(this.#options===true){return-1}if(this.#options===false){return this.value.length}return null}static from(type,value){return new Typed(_gaurd,type,value)}static uint8(v){return n(v,8)}static uint16(v){return n(v,16)}static uint24(v){return n(v,24)}static uint32(v){return n(v,32)}static uint40(v){return n(v,40)}static uint48(v){return n(v,48)}static uint56(v){return n(v,56)}static uint64(v){return n(v,64)}static uint72(v){return n(v,72)}static uint80(v){return n(v,80)}static uint88(v){return n(v,88)}static uint96(v){return n(v,96)}static uint104(v){return n(v,104)}static uint112(v){return n(v,112)}static uint120(v){return n(v,120)}static uint128(v){return n(v,128)}static uint136(v){return n(v,136)}static uint144(v){return n(v,144)}static uint152(v){return n(v,152)}static uint160(v){return n(v,160)}static uint168(v){return n(v,168)}static uint176(v){return n(v,176)}static uint184(v){return n(v,184)}static uint192(v){return n(v,192)}static uint200(v){return n(v,200)}static uint208(v){return n(v,208)}static uint216(v){return n(v,216)}static uint224(v){return n(v,224)}static uint232(v){return n(v,232)}static uint240(v){return n(v,240)}static uint248(v){return n(v,248)}static uint256(v){return n(v,256)}static uint(v){return n(v,256)}static int8(v){return n(v,-8)}static int16(v){return n(v,-16)}static int24(v){return n(v,-24)}static int32(v){return n(v,-32)}static int40(v){return n(v,-40)}static int48(v){return n(v,-48)}static int56(v){return n(v,-56)}static int64(v){return n(v,-64)}static int72(v){return n(v,-72)}static int80(v){return n(v,-80)}static int88(v){return n(v,-88)}static int96(v){return n(v,-96)}static int104(v){return n(v,-104)}static int112(v){return n(v,-112)}static int120(v){return n(v,-120)}static int128(v){return n(v,-128)}static int136(v){return n(v,-136)}static int144(v){return n(v,-144)}static int152(v){return n(v,-152)}static int160(v){return n(v,-160)}static int168(v){return n(v,-168)}static int176(v){return n(v,-176)}static int184(v){return n(v,-184)}static int192(v){return n(v,-192)}static int200(v){return n(v,-200)}static int208(v){return n(v,-208)}static int216(v){return n(v,-216)}static int224(v){return n(v,-224)}static int232(v){return n(v,-232)}static int240(v){return n(v,-240)}static int248(v){return n(v,-248)}static int256(v){return n(v,-256)}static int(v){return n(v,-256)}static bytes1(v){return b(v,1)}static bytes2(v){return b(v,2)}static bytes3(v){return b(v,3)}static bytes4(v){return b(v,4)}static bytes5(v){return b(v,5)}static bytes6(v){return b(v,6)}static bytes7(v){return b(v,7)}static bytes8(v){return b(v,8)}static bytes9(v){return b(v,9)}static bytes10(v){return b(v,10)}static bytes11(v){return b(v,11)}static bytes12(v){return b(v,12)}static bytes13(v){return b(v,13)}static bytes14(v){return b(v,14)}static bytes15(v){return b(v,15)}static bytes16(v){return b(v,16)}static bytes17(v){return b(v,17)}static bytes18(v){return b(v,18)}static bytes19(v){return b(v,19)}static bytes20(v){return b(v,20)}static bytes21(v){return b(v,21)}static bytes22(v){return b(v,22)}static bytes23(v){return b(v,23)}static bytes24(v){return b(v,24)}static bytes25(v){return b(v,25)}static bytes26(v){return b(v,26)}static bytes27(v){return b(v,27)}static bytes28(v){return b(v,28)}static bytes29(v){return b(v,29)}static bytes30(v){return b(v,30)}static bytes31(v){return b(v,31)}static bytes32(v){return b(v,32)}static address(v){return new Typed(_gaurd,"address",v)}static bool(v){return new Typed(_gaurd,"bool",!!v)}static bytes(v){return new Typed(_gaurd,"bytes",v)}static string(v){return new Typed(_gaurd,"string",v)}static array(v,dynamic){throw new Error("not implemented yet")}static tuple(v,name){throw new Error("not implemented yet")}static overrides(v){return new Typed(_gaurd,"overrides",Object.assign({},v))}static isTyped(value){return value&&typeof value==="object"&&"_typedSymbol"in value&&value._typedSymbol===_typedSymbol}static dereference(value,type){if(Typed.isTyped(value)){if(value.type!==type){throw new Error(`invalid type: expecetd ${type}, got ${value.type}`)}return value.value}return value}}class AddressCoder extends Coder{constructor(localName){super("address","address",localName,false)}defaultValue(){return"0x0000000000000000000000000000000000000000"}encode(writer,_value){let value=Typed.dereference(_value,"string");try{value=getAddress(value)}catch(error){return this._throwError(error.message,_value)}return writer.writeValue(value)}decode(reader){return getAddress(toBeHex(reader.readValue(),20))}}class AnonymousCoder extends Coder{coder;constructor(coder){super(coder.name,coder.type,"_",coder.dynamic);this.coder=coder}defaultValue(){return this.coder.defaultValue()}encode(writer,value){return this.coder.encode(writer,value)}decode(reader){return this.coder.decode(reader)}}function pack(writer,coders,values){let arrayValues=[];if(Array.isArray(values)){arrayValues=values}else if(values&&typeof values==="object"){let unique={};arrayValues=coders.map(coder=>{const name=coder.localName;assert(name,"cannot encode object for signature with missing names","INVALID_ARGUMENT",{argument:"values",info:{coder:coder},value:values});assert(!unique[name],"cannot encode object for signature with duplicate names","INVALID_ARGUMENT",{argument:"values",info:{coder:coder},value:values});unique[name]=true;return values[name]})}else{assertArgument(false,"invalid tuple value","tuple",values)}assertArgument(coders.length===arrayValues.length,"types/value length mismatch","tuple",values);let staticWriter=new Writer;let dynamicWriter=new Writer;let updateFuncs=[];coders.forEach((coder,index)=>{let value=arrayValues[index];if(coder.dynamic){let dynamicOffset=dynamicWriter.length;coder.encode(dynamicWriter,value);let updateFunc=staticWriter.writeUpdatableValue();updateFuncs.push(baseOffset=>{updateFunc(baseOffset+dynamicOffset)})}else{coder.encode(staticWriter,value)}});updateFuncs.forEach(func=>{func(staticWriter.length)});let length=writer.appendWriter(staticWriter);length+=writer.appendWriter(dynamicWriter);return length}function unpack(reader,coders){let values=[];let keys=[];let baseReader=reader.subReader(0);coders.forEach(coder=>{let value=null;if(coder.dynamic){let offset=reader.readIndex();let offsetReader=baseReader.subReader(offset);try{value=coder.decode(offsetReader)}catch(error){if(isError(error,"BUFFER_OVERRUN")){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}else{try{value=coder.decode(reader)}catch(error){if(isError(error,"BUFFER_OVERRUN")){throw error}value=error;value.baseType=coder.name;value.name=coder.localName;value.type=coder.type}}if(value==undefined){throw new Error("investigate")}values.push(value);keys.push(coder.localName||null)});return Result.fromItems(values,keys)}class ArrayCoder extends Coder{coder;length;constructor(coder,length,localName){const type=coder.type+"["+(length>=0?length:"")+"]";const dynamic=length===-1||coder.dynamic;super("array",type,localName,dynamic);defineProperties(this,{coder:coder,length:length})}defaultValue(){const defaultChild=this.coder.defaultValue();const result=[];for(let i=0;i<this.length;i++){result.push(defaultChild)}return result}encode(writer,_value){const value=Typed.dereference(_value,"array");if(!Array.isArray(value)){this._throwError("expected array value",value)}let count=this.length;if(count===-1){count=value.length;writer.writeValue(value.length)}assertArgumentCount(value.length,count,"coder array"+(this.localName?" "+this.localName:""));let coders=[];for(let i=0;i<value.length;i++){coders.push(this.coder)}return pack(writer,coders,value)}decode(reader){let count=this.length;if(count===-1){count=reader.readIndex();assert(count*WordSize<=reader.dataLength,"insufficient data length","BUFFER_OVERRUN",{buffer:reader.bytes,offset:count*WordSize,length:reader.dataLength})}let coders=[];for(let i=0;i<count;i++){coders.push(new AnonymousCoder(this.coder))}return unpack(reader,coders)}}class BooleanCoder extends Coder{constructor(localName){super("bool","bool",localName,false)}defaultValue(){return false}encode(writer,_value){const value=Typed.dereference(_value,"bool");return writer.writeValue(value?1:0)}decode(reader){return!!reader.readValue()}}class DynamicBytesCoder extends Coder{constructor(type,localName){super(type,type,localName,true)}defaultValue(){return"0x"}encode(writer,value){value=getBytesCopy(value);let length=writer.writeValue(value.length);length+=writer.writeBytes(value);return length}decode(reader){return reader.readBytes(reader.readIndex(),true)}}class BytesCoder extends DynamicBytesCoder{constructor(localName){super("bytes",localName)}decode(reader){return hexlify(super.decode(reader))}}class FixedBytesCoder extends Coder{size;constructor(size,localName){let name="bytes"+String(size);super(name,name,localName,false);defineProperties(this,{size:size},{size:"number"})}defaultValue(){return"0x0000000000000000000000000000000000000000000000000000000000000000".substring(0,2+this.size*2)}encode(writer,_value){let data=getBytesCopy(Typed.dereference(_value,this.type));if(data.length!==this.size){this._throwError("incorrect data length",_value)}return writer.writeBytes(data)}decode(reader){return hexlify(reader.readBytes(this.size))}}const Empty=new Uint8Array([]);class NullCoder extends Coder{constructor(localName){super("null","",localName,false)}defaultValue(){return null}encode(writer,value){if(value!=null){this._throwError("not null",value)}return writer.writeBytes(Empty)}decode(reader){reader.readBytes(0);return null}}const BN_0$2=BigInt(0);const BN_1=BigInt(1);const BN_MAX_UINT256=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");class NumberCoder extends Coder{size;signed;constructor(size,signed,localName){const name=(signed?"int":"uint")+size*8;super(name,name,localName,false);defineProperties(this,{size:size,signed:signed},{size:"number",signed:"boolean"})}defaultValue(){return 0}encode(writer,_value){let value=getBigInt(Typed.dereference(_value,this.type));let maxUintValue=mask(BN_MAX_UINT256,WordSize*8);if(this.signed){let bounds=mask(maxUintValue,this.size*8-1);if(value>bounds||value<-(bounds+BN_1)){this._throwError("value out-of-bounds",_value)}value=toTwos(value,8*WordSize)}else if(value<BN_0$2||value>mask(maxUintValue,this.size*8)){this._throwError("value out-of-bounds",_value)}return writer.writeValue(value)}decode(reader){let value=mask(reader.readValue(),this.size*8);if(this.signed){value=fromTwos(value,this.size*8)}return value}}class StringCoder extends DynamicBytesCoder{constructor(localName){super("string",localName)}defaultValue(){return""}encode(writer,_value){return super.encode(writer,toUtf8Bytes(Typed.dereference(_value,"string")))}decode(reader){return toUtf8String(super.decode(reader))}}class TupleCoder extends Coder{coders;constructor(coders,localName){let dynamic=false;const types=[];coders.forEach(coder=>{if(coder.dynamic){dynamic=true}types.push(coder.type)});const type="tuple("+types.join(",")+")";super("tuple",type,localName,dynamic);defineProperties(this,{coders:Object.freeze(coders.slice())})}defaultValue(){const values=[];this.coders.forEach(coder=>{values.push(coder.defaultValue())});const uniqueNames=this.coders.reduce((accum,coder)=>{const name=coder.localName;if(name){if(!accum[name]){accum[name]=0}accum[name]++}return accum},{});this.coders.forEach((coder,index)=>{let name=coder.localName;if(!name||uniqueNames[name]!==1){return}if(name==="length"){name="_length"}if(values[name]!=null){return}values[name]=values[index]});return Object.freeze(values)}encode(writer,_value){const value=Typed.dereference(_value,"tuple");return pack(writer,this.coders,value)}decode(reader){return unpack(reader,this.coders)}}function id(value){return keccak256(toUtf8Bytes(value))}function accessSetify(addr,storageKeys){return{address:getAddress(addr),storageKeys:storageKeys.map((storageKey,index)=>{assertArgument(isHexString(storageKey,32),"invalid slot",`storageKeys[${index}]`,storageKey);return storageKey.toLowerCase()})}}function accessListify(value){if(Array.isArray(value)){return value.map((set,index)=>{if(Array.isArray(set)){assertArgument(set.length===2,"invalid slot set",`value[${index}]`,set);return accessSetify(set[0],set[1])}assertArgument(set!=null&&typeof set==="object","invalid address-slot set","value",value);return accessSetify(set.address,set.storageKeys)})}assertArgument(value!=null&&typeof value==="object","invalid access list","value",value);const result=Object.keys(value).map(addr=>{const storageKeys=value[addr].reduce((accum,storageKey)=>{accum[storageKey]=true;return accum},{});return accessSetify(addr,Object.keys(storageKeys).sort())});result.sort((a,b)=>a.address.localeCompare(b.address));return result}function setify(items){const result=new Set;items.forEach(k=>result.add(k));return Object.freeze(result)}const _kwVisibDeploy="external public payable override";const KwVisibDeploy=setify(_kwVisibDeploy.split(" "));const _kwVisib="constant external internal payable private public pure view override";const KwVisib=setify(_kwVisib.split(" "));const _kwTypes="constructor error event fallback function receive struct";const KwTypes=setify(_kwTypes.split(" "));const _kwModifiers="calldata memory storage payable indexed";const KwModifiers=setify(_kwModifiers.split(" "));const _kwOther="tuple returns";const _keywords=[_kwTypes,_kwModifiers,_kwOther,_kwVisib].join(" ");const Keywords=setify(_keywords.split(" "));const SimpleTokens={"(":"OPEN_PAREN",")":"CLOSE_PAREN","[":"OPEN_BRACKET","]":"CLOSE_BRACKET",",":"COMMA","@":"AT"};const regexWhitespacePrefix=new RegExp("^(\\s*)");const regexNumberPrefix=new RegExp("^([0-9]+)");const regexIdPrefix=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");const regexId=new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");const regexType=new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");class TokenString{#offset;#tokens;get offset(){return this.#offset}get length(){return this.#tokens.length-this.#offset}constructor(tokens){this.#offset=0;this.#tokens=tokens.slice()}clone(){return new TokenString(this.#tokens)}reset(){this.#offset=0}#subTokenString(from=0,to=0){return new TokenString(this.#tokens.slice(from,to).map(t=>{return Object.freeze(Object.assign({},t,{match:t.match-from,linkBack:t.linkBack-from,linkNext:t.linkNext-from}))}))}popKeyword(allowed){const top=this.peek();if(top.type!=="KEYWORD"||!allowed.has(top.text)){throw new Error(`expected keyword ${top.text}`)}return this.pop().text}popType(type){if(this.peek().type!==type){const top=this.peek();throw new Error(`expected ${type}; got ${top.type} ${JSON.stringify(top.text)}`)}return this.pop().text}popParen(){const top=this.peek();if(top.type!=="OPEN_PAREN"){throw new Error("bad start")}const result=this.#subTokenString(this.#offset+1,top.match+1);this.#offset=top.match+1;return result}popParams(){const top=this.peek();if(top.type!=="OPEN_PAREN"){throw new Error("bad start")}const result=[];while(this.#offset<top.match-1){const link=this.peek().linkNext;result.push(this.#subTokenString(this.#offset+1,link));this.#offset=link}this.#offset=top.match+1;return result}peek(){if(this.#offset>=this.#tokens.length){throw new Error("out-of-bounds")}return this.#tokens[this.#offset]}peekKeyword(allowed){const top=this.peekType("KEYWORD");return top!=null&&allowed.has(top)?top:null}peekType(type){if(this.length===0){return null}const top=this.peek();return top.type===type?top.text:null}pop(){const result=this.peek();this.#offset++;return result}toString(){const tokens=[];for(let i=this.#offset;i<this.#tokens.length;i++){const token=this.#tokens[i];tokens.push(`${token.type}:${token.text}`)}return`<TokenString ${tokens.join(" ")}>`}}function lex(text){const tokens=[];const throwError=message=>{const token=offset<text.length?JSON.stringify(text[offset]):"$EOI";throw new Error(`invalid token ${token} at ${offset}: ${message}`)};let brackets=[];let commas=[];let offset=0;while(offset<text.length){let cur=text.substring(offset);let match=cur.match(regexWhitespacePrefix);if(match){offset+=match[1].length;cur=text.substring(offset)}const token={depth:brackets.length,linkBack:-1,linkNext:-1,match:-1,type:"",text:"",offset:offset,value:-1};tokens.push(token);let type=SimpleTokens[cur[0]]||"";if(type){token.type=type;token.text=cur[0];offset++;if(type==="OPEN_PAREN"){brackets.push(tokens.length-1);commas.push(tokens.length-1)}else if(type=="CLOSE_PAREN"){if(brackets.length===0){throwError("no matching open bracket")}token.match=brackets.pop();tokens[token.match].match=tokens.length-1;token.depth--;token.linkBack=commas.pop();tokens[token.linkBack].linkNext=tokens.length-1}else if(type==="COMMA"){token.linkBack=commas.pop();tokens[token.linkBack].linkNext=tokens.length-1;commas.push(tokens.length-1)}else if(type==="OPEN_BRACKET"){token.type="BRACKET"}else if(type==="CLOSE_BRACKET"){let suffix=tokens.pop().text;if(tokens.length>0&&tokens[tokens.length-1].type==="NUMBER"){const value=tokens.pop().text;suffix=value+suffix;tokens[tokens.length-1].value=getNumber(value)}if(tokens.length===0||tokens[tokens.length-1].type!=="BRACKET"){throw new Error("missing opening bracket")}tokens[tokens.length-1].text+=suffix}continue}match=cur.match(regexIdPrefix);if(match){token.text=match[1];offset+=token.text.length;if(Keywords.has(token.text)){token.type="KEYWORD";continue}if(token.text.match(regexType)){token.type="TYPE";continue}token.type="ID";continue}match=cur.match(regexNumberPrefix);if(match){token.text=match[1];token.type="NUMBER";offset+=token.text.length;continue}throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`)}return new TokenString(tokens.map(t=>Object.freeze(t)))}function allowSingle(set,allowed){let included=[];for(const key in allowed.keys()){if(set.has(key)){included.push(key)}}if(included.length>1){throw new Error(`conflicting types: ${included.join(", ")}`)}}function consumeName(type,tokens){if(tokens.peekKeyword(KwTypes)){const keyword=tokens.pop().text;if(keyword!==type){throw new Error(`expected ${type}, got ${keyword}`)}}return tokens.popType("ID")}function consumeKeywords(tokens,allowed){const keywords=new Set;while(true){const keyword=tokens.peekType("KEYWORD");if(keyword==null||allowed&&!allowed.has(keyword)){break}tokens.pop();if(keywords.has(keyword)){throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`)}keywords.add(keyword)}return Object.freeze(keywords)}function consumeMutability(tokens){let modifiers=consumeKeywords(tokens,KwVisib);allowSingle(modifiers,setify("constant payable nonpayable".split(" ")));allowSingle(modifiers,setify("pure view payable nonpayable".split(" ")));if(modifiers.has("view")){return"view"}if(modifiers.has("pure")){return"pure"}if(modifiers.has("payable")){return"payable"}if(modifiers.has("nonpayable")){return"nonpayable"}if(modifiers.has("constant")){return"view"}return"nonpayable"}function consumeParams(tokens,allowIndexed){return tokens.popParams().map(t=>ParamType.from(t,allowIndexed))}function consumeGas(tokens){if(tokens.peekType("AT")){tokens.pop();if(tokens.peekType("NUMBER")){return getBigInt(tokens.pop().text)}throw new Error("invalid gas")}return null}function consumeEoi(tokens){if(tokens.length){throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`)}}const regexArrayType=new RegExp(/^(.*)\[([0-9]*)\]$/);function verifyBasicType(type){const match=type.match(regexType);assertArgument(match,"invalid type","type",type);if(type==="uint"){return"uint256"}if(type==="int"){return"int256"}if(match[2]){const length=parseInt(match[2]);assertArgument(length!==0&&length<=32,"invalid bytes length","type",type)}else if(match[3]){const size=parseInt(match[3]);assertArgument(size!==0&&size<=256&&size%8===0,"invalid numeric width","type",type)}return type}const _guard={};const internal$1=Symbol.for("_ethers_internal");const ParamTypeInternal="_ParamTypeInternal";const ErrorFragmentInternal="_ErrorInternal";const EventFragmentInternal="_EventInternal";const ConstructorFragmentInternal="_ConstructorInternal";const FallbackFragmentInternal="_FallbackInternal";const FunctionFragmentInternal="_FunctionInternal";const StructFragmentInternal="_StructInternal";class ParamType{name;type;baseType;indexed;components;arrayLength;arrayChildren;constructor(guard,name,type,baseType,indexed,components,arrayLength,arrayChildren){assertPrivate(guard,_guard,"ParamType");Object.defineProperty(this,internal$1,{value:ParamTypeInternal});if(components){components=Object.freeze(components.slice())}if(baseType==="array"){if(arrayLength==null||arrayChildren==null){throw new Error("")}}else if(arrayLength!=null||arrayChildren!=null){throw new Error("")}if(baseType==="tuple"){if(components==null){throw new Error("")}}else if(components!=null){throw new Error("")}defineProperties(this,{name:name,type:type,baseType:baseType,indexed:indexed,components:components,arrayLength:arrayLength,arrayChildren:arrayChildren})}format(format){if(format==null){format="sighash"}if(format==="json"){const name=this.name||"";if(this.isArray()){const result=JSON.parse(this.arrayChildren.format("json"));result.name=name;result.type+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`;return JSON.stringify(result)}const result={type:this.baseType==="tuple"?"tuple":this.type,name:name};if(typeof this.indexed==="boolean"){result.indexed=this.indexed}if(this.isTuple()){result.components=this.components.map(c=>JSON.parse(c.format(format)))}return JSON.stringify(result)}let result="";if(this.isArray()){result+=this.arrayChildren.format(format);result+=`[${this.arrayLength<0?"":String(this.arrayLength)}]`}else{if(this.isTuple()){result+="("+this.components.map(comp=>comp.format(format)).join(format==="full"?", ":",")+")"}else{result+=this.type}}if(format!=="sighash"){if(this.indexed===true){result+=" indexed"}if(format==="full"&&this.name){result+=" "+this.name}}return result}isArray(){return this.baseType==="array"}isTuple(){return this.baseType==="tuple"}isIndexable(){return this.indexed!=null}walk(value,process){if(this.isArray()){if(!Array.isArray(value)){throw new Error("invalid array value")}if(this.arrayLength!==-1&&value.length!==this.arrayLength){throw new Error("array is wrong length")}const _this=this;return value.map(v=>_this.arrayChildren.walk(v,process))}if(this.isTuple()){if(!Array.isArray(value)){throw new Error("invalid tuple value")}if(value.length!==this.components.length){throw new Error("array is wrong length")}const _this=this;return value.map((v,i)=>_this.components[i].walk(v,process))}return process(this.type,value)}#walkAsync(promises,value,process,setValue){if(this.isArray()){if(!Array.isArray(value)){throw new Error("invalid array value")}if(this.arrayLength!==-1&&value.length!==this.arrayLength){throw new Error("array is wrong length")}const childType=this.arrayChildren;const result=value.slice();result.forEach((value,index)=>{childType.#walkAsync(promises,value,process,value=>{result[index]=value})});setValue(result);return}if(this.isTuple()){const components=this.components;let result;if(Array.isArray(value)){result=value.slice()}else{if(value==null||typeof value!=="object"){throw new Error("invalid tuple value")}result=components.map(param=>{if(!param.name){throw new Error("cannot use object value with unnamed components")}if(!(param.name in value)){throw new Error(`missing value for component ${param.name}`)}return value[param.name]})}if(result.length!==this.components.length){throw new Error("array is wrong length")}result.forEach((value,index)=>{components[index].#walkAsync(promises,value,process,value=>{result[index]=value})});setValue(result);return}const result=process(this.type,value);if(result.then){promises.push(async function(){setValue(await result)}())}else{setValue(result)}}async walkAsync(value,process){const promises=[];const result=[value];this.#walkAsync(promises,value,process,value=>{result[0]=value});if(promises.length){await Promise.all(promises)}return result[0]}static from(obj,allowIndexed){if(ParamType.isParamType(obj)){return obj}if(typeof obj==="string"){try{return ParamType.from(lex(obj),allowIndexed)}catch(error){assertArgument(false,"invalid param type","obj",obj)}}else if(obj instanceof TokenString){let type="",baseType="";let comps=null;if(consumeKeywords(obj,setify(["tuple"])).has("tuple")||obj.peekType("OPEN_PAREN")){baseType="tuple";comps=obj.popParams().map(t=>ParamType.from(t));type=`tuple(${comps.map(c=>c.format()).join(",")})`}else{type=verifyBasicType(obj.popType("TYPE"));baseType=type}let arrayChildren=null;let arrayLength=null;while(obj.length&&obj.peekType("BRACKET")){const bracket=obj.pop();arrayChildren=new ParamType(_guard,"",type,baseType,null,comps,arrayLength,arrayChildren);arrayLength=bracket.value;type+=bracket.text;baseType="array";comps=null}let indexed=null;const keywords=consumeKeywords(obj,KwModifiers);if(keywords.has("indexed")){if(!allowIndexed){throw new Error("")}indexed=true}const name=obj.peekType("ID")?obj.pop().text:"";if(obj.length){throw new Error("leftover tokens")}return new ParamType(_guard,name,type,baseType,indexed,comps,arrayLength,arrayChildren)}const name=obj.name;assertArgument(!name||typeof name==="string"&&name.match(regexId),"invalid name","obj.name",name);let indexed=obj.indexed;if(indexed!=null){assertArgument(allowIndexed,"parameter cannot be indexed","obj.indexed",obj.indexed);indexed=!!indexed}let type=obj.type;let arrayMatch=type.match(regexArrayType);if(arrayMatch){const arrayLength=parseInt(arrayMatch[2]||"-1");const arrayChildren=ParamType.from({type:arrayMatch[1],components:obj.components});return new ParamType(_guard,name||"",type,"array",indexed,null,arrayLength,arrayChildren)}if(type==="tuple"||type.startsWith("tuple(")||type.startsWith("(")){const comps=obj.components!=null?obj.components.map(c=>ParamType.from(c)):null;const tuple=new ParamType(_guard,name||"",type,"tuple",indexed,comps,null,null);return tuple}type=verifyBasicType(obj.type);return new ParamType(_guard,name||"",type,type,indexed,null,null,null)}static isParamType(value){return value&&value[internal$1]===ParamTypeInternal}}class Fragment{type;inputs;constructor(guard,type,inputs){assertPrivate(guard,_guard,"Fragment");inputs=Object.freeze(inputs.slice());defineProperties(this,{type:type,inputs:inputs})}static from(obj){if(typeof obj==="string"){try{Fragment.from(JSON.parse(obj))}catch(e){}return Fragment.from(lex(obj))}if(obj instanceof TokenString){const type=obj.peekKeyword(KwTypes);switch(type){case"constructor":return ConstructorFragment.from(obj);case"error":return ErrorFragment.from(obj);case"event":return EventFragment.from(obj);case"fallback":case"receive":return FallbackFragment.from(obj);case"function":return FunctionFragment.from(obj);case"struct":return StructFragment.from(obj)}}else if(typeof obj==="object"){switch(obj.type){case"constructor":return ConstructorFragment.from(obj);case"error":return ErrorFragment.from(obj);case"event":return EventFragment.from(obj);case"fallback":case"receive":return FallbackFragment.from(obj);case"function":return FunctionFragment.from(obj);case"struct":return StructFragment.from(obj)}assert(false,`unsupported type: ${obj.type}`,"UNSUPPORTED_OPERATION",{operation:"Fragment.from"})}assertArgument(false,"unsupported frgament object","obj",obj)}static isConstructor(value){return ConstructorFragment.isFragment(value)}static isError(value){return ErrorFragment.isFragment(value)}static isEvent(value){return EventFragment.isFragment(value)}static isFunction(value){return FunctionFragment.isFragment(value)}static isStruct(value){return StructFragment.isFragment(value)}}class NamedFragment extends Fragment{name;constructor(guard,type,name,inputs){super(guard,type,inputs);assertArgument(typeof name==="string"&&name.match(regexId),"invalid identifier","name",name);inputs=Object.freeze(inputs.slice());defineProperties(this,{name:name})}}function joinParams(format,params){return"("+params.map(p=>p.format(format)).join(format==="full"?", ":",")+")"}class ErrorFragment extends NamedFragment{constructor(guard,name,inputs){super(guard,"error",name,inputs);Object.defineProperty(this,internal$1,{value:ErrorFragmentInternal})}get selector(){return id(this.format("sighash")).substring(0,10)}format(format){if(format==null){format="sighash"}if(format==="json"){return JSON.stringify({type:"error",name:this.name,inputs:this.inputs.map(input=>JSON.parse(input.format(format)))})}const result=[];if(format!=="sighash"){result.push("error")}result.push(this.name+joinParams(format,this.inputs));return result.join(" ")}static from(obj){if(ErrorFragment.isFragment(obj)){return obj}if(typeof obj==="string"){return ErrorFragment.from(lex(obj))}else if(obj instanceof TokenString){const name=consumeName("error",obj);const inputs=consumeParams(obj);consumeEoi(obj);return new ErrorFragment(_guard,name,inputs)}return new ErrorFragment(_guard,obj.name,obj.inputs?obj.inputs.map(ParamType.from):[])}static isFragment(value){return value&&value[internal$1]===ErrorFragmentInternal}}class EventFragment extends NamedFragment{anonymous;constructor(guard,name,inputs,anonymous){super(guard,"event",name,inputs);Object.defineProperty(this,internal$1,{value:EventFragmentInternal});defineProperties(this,{anonymous:anonymous})}get topicHash(){return id(this.format("sighash"))}format(format){if(format==null){format="sighash"}if(format==="json"){return JSON.stringify({type:"event",anonymous:this.anonymous,name:this.name,inputs:this.inputs.map(i=>JSON.parse(i.format(format)))})}const result=[];if(format!=="sighash"){result.push("event")}result.push(this.name+joinParams(format,this.inputs));if(format!=="sighash"&&this.anonymous){result.push("anonymous")}return result.join(" ")}static getTopicHash(name,params){params=(params||[]).map(p=>ParamType.from(p));const fragment=new EventFragment(_guard,name,params,false);return fragment.topicHash}static from(obj){if(EventFragment.isFragment(obj)){return obj}if(typeof obj==="string"){try{return EventFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid event fragment","obj",obj)}}else if(obj instanceof TokenString){const name=consumeName("event",obj);const inputs=consumeParams(obj,true);const anonymous=!!consumeKeywords(obj,setify(["anonymous"])).has("anonymous");consumeEoi(obj);return new EventFragment(_guard,name,inputs,anonymous)}return new EventFragment(_guard,obj.name,obj.inputs?obj.inputs.map(p=>ParamType.from(p,true)):[],!!obj.anonymous)}static isFragment(value){return value&&value[internal$1]===EventFragmentInternal}}class ConstructorFragment extends Fragment{payable;gas;constructor(guard,type,inputs,payable,gas){super(guard,type,inputs);Object.defineProperty(this,internal$1,{value:ConstructorFragmentInternal});defineProperties(this,{payable:payable,gas:gas})}format(format){assert(format!=null&&format!=="sighash","cannot format a constructor for sighash","UNSUPPORTED_OPERATION",{operation:"format(sighash)"});if(format==="json"){return JSON.stringify({type:"constructor",stateMutability:this.payable?"payable":"undefined",payable:this.payable,gas:this.gas!=null?this.gas:undefined,inputs:this.inputs.map(i=>JSON.parse(i.format(format)))})}const result=[`constructor${joinParams(format,this.inputs)}`];if(this.payable){result.push("payable")}if(this.gas!=null){result.push(`@${this.gas.toString()}`)}return result.join(" ")}static from(obj){if(ConstructorFragment.isFragment(obj)){return obj}if(typeof obj==="string"){try{return ConstructorFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid constuctor fragment","obj",obj)}}else if(obj instanceof TokenString){consumeKeywords(obj,setify(["constructor"]));const inputs=consumeParams(obj);const payable=!!consumeKeywords(obj,KwVisibDeploy).has("payable");const gas=consumeGas(obj);consumeEoi(obj);return new ConstructorFragment(_guard,"constructor",inputs,payable,gas)}return new ConstructorFragment(_guard,"constructor",obj.inputs?obj.inputs.map(ParamType.from):[],!!obj.payable,obj.gas!=null?obj.gas:null)}static isFragment(value){return value&&value[internal$1]===ConstructorFragmentInternal}}class FallbackFragment extends Fragment{payable;constructor(guard,inputs,payable){super(guard,"fallback",inputs);Object.defineProperty(this,internal$1,{value:FallbackFragmentInternal});defineProperties(this,{payable:payable})}format(format){const type=this.inputs.length===0?"receive":"fallback";if(format==="json"){const stateMutability=this.payable?"payable":"nonpayable";return JSON.stringify({type:type,stateMutability:stateMutability})}return`${type}()${this.payable?" payable":""}`}static from(obj){if(FallbackFragment.isFragment(obj)){return obj}if(typeof obj==="string"){try{return FallbackFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid fallback fragment","obj",obj)}}else if(obj instanceof TokenString){const errorObj=obj.toString();const topIsValid=obj.peekKeyword(setify(["fallback","receive"]));assertArgument(topIsValid,"type must be fallback or receive","obj",errorObj);const type=obj.popKeyword(setify(["fallback","receive"]));if(type==="receive"){const inputs=consumeParams(obj);assertArgument(inputs.length===0,`receive cannot have arguments`,"obj.inputs",inputs);consumeKeywords(obj,setify(["payable"]));consumeEoi(obj);return new FallbackFragment(_guard,[],true)}let inputs=consumeParams(obj);if(inputs.length){assertArgument(inputs.length===1&&inputs[0].type==="bytes","invalid fallback inputs","obj.inputs",inputs.map(i=>i.format("minimal")).join(", "))}else{inputs=[ParamType.from("bytes")]}const mutability=consumeMutability(obj);assertArgument(mutability==="nonpayable"||mutability==="payable","fallback cannot be constants","obj.stateMutability",mutability);if(consumeKeywords(obj,setify(["returns"])).has("returns")){const outputs=consumeParams(obj);assertArgument(outputs.length===1&&outputs[0].type==="bytes","invalid fallback outputs","obj.outputs",outputs.map(i=>i.format("minimal")).join(", "))}consumeEoi(obj);return new FallbackFragment(_guard,inputs,mutability==="payable")}if(obj.type==="receive"){return new FallbackFragment(_guard,[],true)}if(obj.type==="fallback"){const inputs=[ParamType.from("bytes")];const payable=obj.stateMutability==="payable";return new FallbackFragment(_guard,inputs,payable)}assertArgument(false,"invalid fallback description","obj",obj)}static isFragment(value){return value&&value[internal$1]===FallbackFragmentInternal}}class FunctionFragment extends NamedFragment{constant;outputs;stateMutability;payable;gas;constructor(guard,name,stateMutability,inputs,outputs,gas){super(guard,"function",name,inputs);Object.defineProperty(this,internal$1,{value:FunctionFragmentInternal});outputs=Object.freeze(outputs.slice());const constant=stateMutability==="view"||stateMutability==="pure";const payable=stateMutability==="payable";defineProperties(this,{constant:constant,gas:gas,outputs:outputs,payable:payable,stateMutability:stateMutability})}get selector(){return id(this.format("sighash")).substring(0,10)}format(format){if(format==null){format="sighash"}if(format==="json"){return JSON.stringify({type:"function",name:this.name,constant:this.constant,stateMutability:this.stateMutability!=="nonpayable"?this.stateMutability:undefined,payable:this.payable,gas:this.gas!=null?this.gas:undefined,inputs:this.inputs.map(i=>JSON.parse(i.format(format))),outputs:this.outputs.map(o=>JSON.parse(o.format(format)))})}const result=[];if(format!=="sighash"){result.push("function")}result.push(this.name+joinParams(format,this.inputs));if(format!=="sighash"){if(this.stateMutability!=="nonpayable"){result.push(this.stateMutability)}if(this.outputs&&this.outputs.length){result.push("returns");result.push(joinParams(format,this.outputs))}if(this.gas!=null){result.push(`@${this.gas.toString()}`)}}return result.join(" ")}static getSelector(name,params){params=(params||[]).map(p=>ParamType.from(p));const fragment=new FunctionFragment(_guard,name,"view",params,[],null);return fragment.selector}static from(obj){if(FunctionFragment.isFragment(obj)){return obj}if(typeof obj==="string"){try{return FunctionFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid function fragment","obj",obj)}}else if(obj instanceof TokenString){const name=consumeName("function",obj);const inputs=consumeParams(obj);const mutability=consumeMutability(obj);let outputs=[];if(consumeKeywords(obj,setify(["returns"])).has("returns")){outputs=consumeParams(obj)}const gas=consumeGas(obj);consumeEoi(obj);return new FunctionFragment(_guard,name,mutability,inputs,outputs,gas)}let stateMutability=obj.stateMutability;if(stateMutability==null){stateMutability="payable";if(typeof obj.constant==="boolean"){stateMutability="view";if(!obj.constant){stateMutability="payable";if(typeof obj.payable==="boolean"&&!obj.payable){stateMutability="nonpayable"}}}else if(typeof obj.payable==="boolean"&&!obj.payable){stateMutability="nonpayable"}}return new FunctionFragment(_guard,obj.name,stateMutability,obj.inputs?obj.inputs.map(ParamType.from):[],obj.outputs?obj.outputs.map(ParamType.from):[],obj.gas!=null?obj.gas:null)}static isFragment(value){return value&&value[internal$1]===FunctionFragmentInternal}}class StructFragment extends NamedFragment{constructor(guard,name,inputs){super(guard,"struct",name,inputs);Object.defineProperty(this,internal$1,{value:StructFragmentInternal})}format(){throw new Error("@TODO")}static from(obj){if(typeof obj==="string"){try{return StructFragment.from(lex(obj))}catch(error){assertArgument(false,"invalid struct fragment","obj",obj)}}else if(obj instanceof TokenString){const name=consumeName("struct",obj);const inputs=consumeParams(obj);consumeEoi(obj);return new StructFragment(_guard,name,inputs)}return new StructFragment(_guard,obj.name,obj.inputs?obj.inputs.map(ParamType.from):[])}static isFragment(value){return value&&value[internal$1]===StructFragmentInternal}}const PanicReasons$1=new Map;PanicReasons$1.set(0,"GENERIC_PANIC");PanicReasons$1.set(1,"ASSERT_FALSE");PanicReasons$1.set(17,"OVERFLOW");PanicReasons$1.set(18,"DIVIDE_BY_ZERO");PanicReasons$1.set(33,"ENUM_RANGE_ERROR");PanicReasons$1.set(34,"BAD_STORAGE_DATA");PanicReasons$1.set(49,"STACK_UNDERFLOW");PanicReasons$1.set(50,"ARRAY_RANGE_ERROR");PanicReasons$1.set(65,"OUT_OF_MEMORY");PanicReasons$1.set(81,"UNINITIALIZED_FUNCTION_CALL");const paramTypeBytes=new RegExp(/^bytes([0-9]*)$/);const paramTypeNumber=new RegExp(/^(u?int)([0-9]*)$/);let defaultCoder=null;let defaultMaxInflation=1024;function getBuiltinCallException(action,tx,data,abiCoder){let message="missing revert data";let reason=null;const invocation=null;let revert=null;if(data){message="execution reverted";const bytes=getBytes(data);data=hexlify(data);if(bytes.length===0){message+=" (no data present; likely require(false) occurred";reason="require(false)"}else if(bytes.length%32!==4){message+=" (could not decode reason; invalid data length)"}else if(hexlify(bytes.slice(0,4))==="0x08c379a0"){try{reason=abiCoder.decode(["string"],bytes.slice(4))[0];revert={signature:"Error(string)",name:"Error",args:[reason]};message+=`: ${JSON.stringify(reason)}`}catch(error){message+=" (could not decode reason; invalid string data)"}}else if(hexlify(bytes.slice(0,4))==="0x4e487b71"){try{const code=Number(abiCoder.decode(["uint256"],bytes.slice(4))[0]);revert={signature:"Panic(uint256)",name:"Panic",args:[code]};reason=`Panic due to ${PanicReasons$1.get(code)||"UNKNOWN"}(${code})`;message+=`: ${reason}`}catch(error){message+=" (could not decode panic code)"}}else{message+=" (unknown custom error)"}}const transaction={to:tx.to?getAddress(tx.to):null,data:tx.data||"0x"};if(tx.from){transaction.from=getAddress(tx.from)}return makeError(message,"CALL_EXCEPTION",{action:action,data:data,reason:reason,transaction:transaction,invocation:invocation,revert:revert})}class AbiCoder{#getCoder(param){if(param.isArray()){return new ArrayCoder(this.#getCoder(param.arrayChildren),param.arrayLength,param.name)}if(param.isTuple()){return new TupleCoder(param.components.map(c=>this.#getCoder(c)),param.name)}switch(param.baseType){case"address":return new AddressCoder(param.name);case"bool":return new BooleanCoder(param.name);case"string":return new StringCoder(param.name);case"bytes":return new BytesCoder(param.name);case"":return new NullCoder(param.name)}let match=param.type.match(paramTypeNumber);if(match){let size=parseInt(match[2]||"256");assertArgument(size!==0&&size<=256&&size%8===0,"invalid "+match[1]+" bit length","param",param);return new NumberCoder(size/8,match[1]==="int",param.name)}match=param.type.match(paramTypeBytes);if(match){let size=parseInt(match[1]);assertArgument(size!==0&&size<=32,"invalid bytes length","param",param);return new FixedBytesCoder(size,param.name)}assertArgument(false,"invalid type","type",param.type)}getDefaultValue(types){const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");return coder.defaultValue()}encode(types,values){assertArgumentCount(values.length,types.length,"types/values length mismatch");const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");const writer=new Writer;coder.encode(writer,values);return writer.data}decode(types,data,loose){const coders=types.map(type=>this.#getCoder(ParamType.from(type)));const coder=new TupleCoder(coders,"_");return coder.decode(new Reader(data,loose,defaultMaxInflation))}static _setDefaultMaxInflation(value){assertArgument(typeof value==="number"&&Number.isInteger(value),"invalid defaultMaxInflation factor","value",value);defaultMaxInflation=value}static defaultAbiCoder(){if(defaultCoder==null){defaultCoder=new AbiCoder}return defaultCoder}static getBuiltinCallException(action,tx,data){return getBuiltinCallException(action,tx,data,AbiCoder.defaultAbiCoder())}}class LogDescription{fragment;name;signature;topic;args;constructor(fragment,topic,args){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,signature:signature,topic:topic,args:args})}}class TransactionDescription{fragment;name;args;signature;selector;value;constructor(fragment,selector,args,value){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,args:args,signature:signature,selector:selector,value:value})}}class ErrorDescription{fragment;name;args;signature;selector;constructor(fragment,selector,args){const name=fragment.name,signature=fragment.format();defineProperties(this,{fragment:fragment,name:name,args:args,signature:signature,selector:selector})}}class Indexed{hash;_isIndexed;static isIndexed(value){return!!(value&&value._isIndexed)}constructor(hash){defineProperties(this,{hash:hash,_isIndexed:true})}}const PanicReasons={0:"generic panic",1:"assert(false)",17:"arithmetic overflow",18:"division or modulo by zero",33:"enum overflow",34:"invalid encoded storage byte array accessed",49:"out-of-bounds array access; popping on an empty array",50:"out-of-bounds access of an array or bytesN",65:"out of memory",81:"uninitialized function"};const BuiltinErrors={"0x08c379a0":{signature:"Error(string)",name:"Error",inputs:["string"],reason:message=>{return`reverted with reason string ${JSON.stringify(message)}`}},"0x4e487b71":{signature:"Panic(uint256)",name:"Panic",inputs:["uint256"],reason:code=>{let reason="unknown panic code";if(code>=0&&code<=255&&PanicReasons[code.toString()]){reason=PanicReasons[code.toString()]}return`reverted with panic code 0x${code.toString(16)} (${reason})`}}};class Interface{fragments;deploy;fallback;receive;#errors;#events;#functions;#abiCoder;constructor(fragments){let abi=[];if(typeof fragments==="string"){abi=JSON.parse(fragments)}else{abi=fragments}this.#functions=new Map;this.#errors=new Map;this.#events=new Map;const frags=[];for(const a of abi){try{frags.push(Fragment.from(a))}catch(error){console.log(`[Warning] Invalid Fragment ${JSON.stringify(a)}:`,error.message)}}defineProperties(this,{fragments:Object.freeze(frags)});let fallback=null;let receive=false;this.#abiCoder=this.getAbiCoder();this.fragments.forEach((fragment,index)=>{let bucket;switch(fragment.type){case"constructor":if(this.deploy){console.log("duplicate definition - constructor");return}defineProperties(this,{deploy:fragment});return;case"fallback":if(fragment.inputs.length===0){receive=true}else{assertArgument(!fallback||fragment.payable!==fallback.payable,"conflicting fallback fragments",`fragments[${index}]`,fragment);fallback=fragment;receive=fallback.payable}return;case"function":bucket=this.#functions;break;case"event":bucket=this.#events;break;case"error":bucket=this.#errors;break;default:return}const signature=fragment.format();if(bucket.has(signature)){return}bucket.set(signature,fragment)});if(!this.deploy){defineProperties(this,{deploy:ConstructorFragment.from("constructor()")})}defineProperties(this,{fallback:fallback,receive:receive})}format(minimal){const format=minimal?"minimal":"full";const abi=this.fragments.map(f=>f.format(format));return abi}formatJson(){const abi=this.fragments.map(f=>f.format("json"));return JSON.stringify(abi.map(j=>JSON.parse(j)))}getAbiCoder(){return AbiCoder.defaultAbiCoder()}#getFunction(key,values,forceUnique){if(isHexString(key)){const selector=key.toLowerCase();for(const fragment of this.#functions.values()){if(selector===fragment.selector){return fragment}}return null}if(key.indexOf("(")===-1){const matching=[];for(const[name,fragment]of this.#functions){if(name.split("(")[0]===key){matching.push(fragment)}}if(values){const lastValue=values.length>0?values[values.length-1]:null;let valueLength=values.length;let allowOptions=true;if(Typed.isTyped(lastValue)&&lastValue.type==="overrides"){allowOptions=false;valueLength--}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs.length;if(inputs!==valueLength&&(!allowOptions||inputs!==valueLength-1)){matching.splice(i,1)}}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs;for(let j=0;j<values.length;j++){if(!Typed.isTyped(values[j])){continue}if(j>=inputs.length){if(values[j].type==="overrides"){continue}matching.splice(i,1);break}if(values[j].type!==inputs[j].baseType){matching.splice(i,1);break}}}}if(matching.length===1&&values&&values.length!==matching[0].inputs.length){const lastArg=values[values.length-1];if(lastArg==null||Array.isArray(lastArg)||typeof lastArg!=="object"){matching.splice(0,1)}}if(matching.length===0){return null}if(matching.length>1&&forceUnique){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(", ");assertArgument(false,`ambiguous function description (i.e. matches ${matchStr})`,"key",key)}return matching[0]}const result=this.#functions.get(FunctionFragment.from(key).format());if(result){return result}return null}getFunctionName(key){const fragment=this.#getFunction(key,null,false);assertArgument(fragment,"no matching function","key",key);return fragment.name}hasFunction(key){return!!this.#getFunction(key,null,false)}getFunction(key,values){return this.#getFunction(key,values||null,true)}forEachFunction(callback){const names=Array.from(this.#functions.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#functions.get(name),i)}}#getEvent(key,values,forceUnique){if(isHexString(key)){const eventTopic=key.toLowerCase();for(const fragment of this.#events.values()){if(eventTopic===fragment.topicHash){return fragment}}return null}if(key.indexOf("(")===-1){const matching=[];for(const[name,fragment]of this.#events){if(name.split("(")[0]===key){matching.push(fragment)}}if(values){for(let i=matching.length-1;i>=0;i--){if(matching[i].inputs.length<values.length){matching.splice(i,1)}}for(let i=matching.length-1;i>=0;i--){const inputs=matching[i].inputs;for(let j=0;j<values.length;j++){if(!Typed.isTyped(values[j])){continue}if(values[j].type!==inputs[j].baseType){matching.splice(i,1);break}}}}if(matching.length===0){return null}if(matching.length>1&&forceUnique){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(", ");assertArgument(false,`ambiguous event description (i.e. matches ${matchStr})`,"key",key)}return matching[0]}const result=this.#events.get(EventFragment.from(key).format());if(result){return result}return null}getEventName(key){const fragment=this.#getEvent(key,null,false);assertArgument(fragment,"no matching event","key",key);return fragment.name}hasEvent(key){return!!this.#getEvent(key,null,false)}getEvent(key,values){return this.#getEvent(key,values||null,true)}forEachEvent(callback){const names=Array.from(this.#events.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#events.get(name),i)}}getError(key,values){if(isHexString(key)){const selector=key.toLowerCase();if(BuiltinErrors[selector]){return ErrorFragment.from(BuiltinErrors[selector].signature)}for(const fragment of this.#errors.values()){if(selector===fragment.selector){return fragment}}return null}if(key.indexOf("(")===-1){const matching=[];for(const[name,fragment]of this.#errors){if(name.split("(")[0]===key){matching.push(fragment)}}if(matching.length===0){if(key==="Error"){return ErrorFragment.from("error Error(string)")}if(key==="Panic"){return ErrorFragment.from("error Panic(uint256)")}return null}else if(matching.length>1){const matchStr=matching.map(m=>JSON.stringify(m.format())).join(", ");assertArgument(false,`ambiguous error description (i.e. ${matchStr})`,"name",key)}return matching[0]}key=ErrorFragment.from(key).format();if(key==="Error(string)"){return ErrorFragment.from("error Error(string)")}if(key==="Panic(uint256)"){return ErrorFragment.from("error Panic(uint256)")}const result=this.#errors.get(key);if(result){return result}return null}forEachError(callback){const names=Array.from(this.#errors.keys());names.sort((a,b)=>a.localeCompare(b));for(let i=0;i<names.length;i++){const name=names[i];callback(this.#errors.get(name),i)}}_decodeParams(params,data){return this.#abiCoder.decode(params,data)}_encodeParams(params,values){return this.#abiCoder.encode(params,values)}encodeDeploy(values){return this._encodeParams(this.deploy.inputs,values||[])}decodeErrorResult(fragment,data){if(typeof fragment==="string"){const f=this.getError(fragment);assertArgument(f,"unknown error","fragment",fragment);fragment=f}assertArgument(dataSlice(data,0,4)===fragment.selector,`data signature does not match error ${fragment.name}.`,"data",data);return this._decodeParams(fragment.inputs,dataSlice(data,4))}encodeErrorResult(fragment,values){if(typeof fragment==="string"){const f=this.getError(fragment);assertArgument(f,"unknown error","fragment",fragment);fragment=f}return concat([fragment.selector,this._encodeParams(fragment.inputs,values||[])])}decodeFunctionData(fragment,data){if(typeof fragment==="string"){const f=this.getFunction(fragment);assertArgument(f,"unknown function","fragment",fragment);fragment=f}assertArgument(dataSlice(data,0,4)===fragment.selector,`data signature does not match function ${fragment.name}.`,"data",data);return this._decodeParams(fragment.inputs,dataSlice(data,4))}encodeFunctionData(fragment,values){if(typeof fragment==="string"){const f=this.getFunction(fragment);assertArgument(f,"unknown function","fragment",fragment);fragment=f}return concat([fragment.selector,this._encodeParams(fragment.inputs,values||[])])}decodeFunctionResult(fragment,data){if(typeof fragment==="string"){const f=this.getFunction(fragment);assertArgument(f,"unknown function","fragment",fragment);fragment=f}let message="invalid length for result data";const bytes=getBytesCopy(data);if(bytes.length%32===0){try{return this.#abiCoder.decode(fragment.outputs,bytes)}catch(error){message="could not decode result data"}}assert(false,message,"BAD_DATA",{value:hexlify(bytes),info:{method:fragment.name,signature:fragment.format()}})}makeError(_data,tx){const data=getBytes(_data,"data");const error=AbiCoder.getBuiltinCallException("call",tx,data);const customPrefix="execution reverted (unknown custom error)";if(error.message.startsWith(customPrefix)){const selector=hexlify(data.slice(0,4));const ef=this.getError(selector);if(ef){try{const args=this.#abiCoder.decode(ef.inputs,data.slice(4));error.revert={name:ef.name,signature:ef.format(),args:args};error.reason=error.revert.signature;error.message=`execution reverted: ${error.reason}`}catch(e){error.message=`execution reverted (coult not decode custom error)`}}}const parsed=this.parseTransaction(tx);if(parsed){error.invocation={method:parsed.name,signature:parsed.signature,args:parsed.args}}return error}encodeFunctionResult(fragment,values){if(typeof fragment==="string"){const f=this.getFunction(fragment);assertArgument(f,"unknown function","fragment",fragment);fragment=f}return hexlify(this.#abiCoder.encode(fragment.outputs,values||[]))}encodeFilterTopics(fragment,values){if(typeof fragment==="string"){const f=this.getEvent(fragment);assertArgument(f,"unknown event","eventFragment",fragment);fragment=f}assert(values.length<=fragment.inputs.length,`too many arguments for ${fragment.format()}`,"UNEXPECTED_ARGUMENT",{count:values.length,expectedCount:fragment.inputs.length});const topics=[];if(!fragment.anonymous){topics.push(fragment.topicHash)}const encodeTopic=(param,value)=>{if(param.type==="string"){return id(value)}else if(param.type==="bytes"){return keccak256(hexlify(value))}if(param.type==="bool"&&typeof value==="boolean"){value=value?"0x01":"0x00"}else if(param.type.match(/^u?int/)){value=toBeHex(value)}else if(param.type.match(/^bytes/)){value=zeroPadBytes(value,32)}else if(param.type==="address"){this.#abiCoder.encode(["address"],[value])}return zeroPadValue(hexlify(value),32)};values.forEach((value,index)=>{const param=fragment.inputs[index];if(!param.indexed){assertArgument(value==null,"cannot filter non-indexed parameters; must be null","contract."+param.name,value);return}if(value==null){topics.push(null)}else if(param.baseType==="array"||param.baseType==="tuple"){assertArgument(false,"filtering with tuples or arrays not supported","contract."+param.name,value)}else if(Array.isArray(value)){topics.push(value.map(value=>encodeTopic(param,value)))}else{topics.push(encodeTopic(param,value))}});while(topics.length&&topics[topics.length-1]===null){topics.pop()}return topics}encodeEventLog(fragment,values){if(typeof fragment==="string"){const f=this.getEvent(fragment);assertArgument(f,"unknown event","eventFragment",fragment);fragment=f}const topics=[];const dataTypes=[];const dataValues=[];if(!fragment.anonymous){topics.push(fragment.topicHash)}assertArgument(values.length===fragment.inputs.length,"event arguments/values mismatch","values",values);fragment.inputs.forEach((param,index)=>{const value=values[index];if(param.indexed){if(param.type==="string"){topics.push(id(value))}else if(param.type==="bytes"){topics.push(keccak256(value))}else if(param.baseType==="tuple"||param.baseType==="array"){throw new Error("not implemented")}else{topics.push(this.#abiCoder.encode([param.type],[value]))}}else{dataTypes.push(param);dataValues.push(value)}});return{data:this.#abiCoder.encode(dataTypes,dataValues),topics:topics}}decodeEventLog(fragment,data,topics){if(typeof fragment==="string"){const f=this.getEvent(fragment);assertArgument(f,"unknown event","eventFragment",fragment);fragment=f}if(topics!=null&&!fragment.anonymous){const eventTopic=fragment.topicHash;assertArgument(isHexString(topics[0],32)&&topics[0].toLowerCase()===eventTopic,"fragment/topic mismatch","topics[0]",topics[0]);topics=topics.slice(1)}const indexed=[];const nonIndexed=[];const dynamic=[];fragment.inputs.forEach((param,index)=>{if(param.indexed){if(param.type==="string"||param.type==="bytes"||param.baseType==="tuple"||param.baseType==="array"){indexed.push(ParamType.from({type:"bytes32",name:param.name}));dynamic.push(true)}else{indexed.push(param);dynamic.push(false)}}else{nonIndexed.push(param);dynamic.push(false)}});const resultIndexed=topics!=null?this.#abiCoder.decode(indexed,concat(topics)):null;const resultNonIndexed=this.#abiCoder.decode(nonIndexed,data,true);const values=[];const keys=[];let nonIndexedIndex=0,indexedIndex=0;fragment.inputs.forEach((param,index)=>{let value=null;if(param.indexed){if(resultIndexed==null){value=new Indexed(null)}else if(dynamic[index]){value=new Indexed(resultIndexed[indexedIndex++])}else{try{value=resultIndexed[indexedIndex++]}catch(error){value=error}}}else{try{value=resultNonIndexed[nonIndexedIndex++]}catch(error){value=error}}values.push(value);keys.push(param.name||null)});return Result.fromItems(values,keys)}parseTransaction(tx){const data=getBytes(tx.data,"tx.data");const value=getBigInt(tx.value!=null?tx.value:0,"tx.value");const fragment=this.getFunction(hexlify(data.slice(0,4)));if(!fragment){return null}const args=this.#abiCoder.decode(fragment.inputs,data.slice(4));return new TransactionDescription(fragment,fragment.selector,args,value)}parseCallResult(data){throw new Error("@TODO")}parseLog(log){const fragment=this.getEvent(log.topics[0]);if(!fragment||fragment.anonymous){return null}return new LogDescription(fragment,fragment.topicHash,this.decodeEventLog(fragment,log.data,log.topics))}parseError(data){const hexData=hexlify(data);const fragment=this.getError(dataSlice(hexData,0,4));if(!fragment){return null}const args=this.#abiCoder.decode(fragment.inputs,dataSlice(hexData,4));return new ErrorDescription(fragment,fragment.selector,args)}static from(value){if(value instanceof Interface){return value}if(typeof value==="string"){return new Interface(JSON.parse(value))}if(typeof value.formatJson==="function"){return new Interface(value.formatJson())}if(typeof value.format==="function"){return new Interface(value.format("json"))}return new Interface(value)}}const BN_0$1=BigInt(0);function toJson(value){if(value==null){return null}return value.toString()}function copyRequest(req){const result={};if(req.to){result.to=req.to}if(req.from){result.from=req.from}if(req.data){result.data=hexlify(req.data)}const bigIntKeys="chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);for(const key of bigIntKeys){if(!(key in req)||req[key]==null){continue}result[key]=getBigInt(req[key],`request.${key}`)}const numberKeys="type,nonce".split(/,/);for(const key of numberKeys){if(!(key in req)||req[key]==null){continue}result[key]=getNumber(req[key],`request.${key}`)}if(req.accessList){result.accessList=accessListify(req.accessList)}if("blockTag"in req){result.blockTag=req.blockTag}if("enableCcipRead"in req){result.enableCcipRead=!!req.enableCcipRead}if("customData"in req){result.customData=req.customData}if("blobVersionedHashes"in req&&req.blobVersionedHashes){result.blobVersionedHashes=req.blobVersionedHashes.slice()}if("kzg"in req){result.kzg=req.kzg}if("blobs"in req&&req.blobs){result.blobs=req.blobs.map(b=>{if(isBytesLike(b)){return hexlify(b)}return Object.assign({},b)})}return result}class Log{provider;transactionHash;blockHash;blockNumber;removed;address;data;topics;index;transactionIndex;constructor(log,provider){this.provider=provider;const topics=Object.freeze(log.topics.slice());defineProperties(this,{transactionHash:log.transactionHash,blockHash:log.blockHash,blockNumber:log.blockNumber,removed:log.removed,address:log.address,data:log.data,topics:topics,index:log.index,transactionIndex:log.transactionIndex})}toJSON(){const{address,blockHash,blockNumber,data,index,removed,topics,transactionHash,transactionIndex}=this;return{_type:"log",address:address,blockHash:blockHash,blockNumber:blockNumber,data:data,index:index,removed:removed,topics:topics,transactionHash:transactionHash,transactionIndex:transactionIndex}}async getBlock(){const block=await this.provider.getBlock(this.blockHash);assert(!!block,"failed to find transaction","UNKNOWN_ERROR",{});return block}async getTransaction(){const tx=await this.provider.getTransaction(this.transactionHash);assert(!!tx,"failed to find transaction","UNKNOWN_ERROR",{});return tx}async getTransactionReceipt(){const receipt=await this.provider.getTransactionReceipt(this.transactionHash);assert(!!receipt,"failed to find transaction receipt","UNKNOWN_ERROR",{});return receipt}removedEvent(){return createRemovedLogFilter(this)}}class TransactionReceipt{provider;to;from;contractAddress;hash;index;blockHash;blockNumber;logsBloom;gasUsed;blobGasUsed;cumulativeGasUsed;gasPrice;blobGasPrice;type;status;root;#logs;constructor(tx,provider){this.#logs=Object.freeze(tx.logs.map(log=>{return new Log(log,provider)}));let gasPrice=BN_0$1;if(tx.effectiveGasPrice!=null){gasPrice=tx.effectiveGasPrice}else if(tx.gasPrice!=null){gasPrice=tx.gasPrice}defineProperties(this,{provider:provider,to:tx.to,from:tx.from,contractAddress:tx.contractAddress,hash:tx.hash,index:tx.index,blockHash:tx.blockHash,blockNumber:tx.blockNumber,logsBloom:tx.logsBloom,gasUsed:tx.gasUsed,cumulativeGasUsed:tx.cumulativeGasUsed,blobGasUsed:tx.blobGasUsed,gasPrice:gasPrice,blobGasPrice:tx.blobGasPrice,type:tx.type,status:tx.status,root:tx.root})}get logs(){return this.#logs}toJSON(){const{to,from,contractAddress,hash,index,blockHash,blockNumber,logsBloom,logs,status,root}=this;return{_type:"TransactionReceipt",blockHash:blockHash,blockNumber:blockNumber,contractAddress:contractAddress,cumulativeGasUsed:toJson(this.cumulativeGasUsed),from:from,gasPrice:toJson(this.gasPrice),blobGasUsed:toJson(this.blobGasUsed),blobGasPrice:toJson(this.blobGasPrice),gasUsed:toJson(this.gasUsed),hash:hash,index:index,logs:logs,logsBloom:logsBloom,root:root,status:status,to:to}}get length(){return this.logs.length}[Symbol.iterator](){let index=0;return{next:()=>{if(index<this.length){return{value:this.logs[index++],done:false}}return{value:undefined,done:true}}}}get fee(){return this.gasUsed*this.gasPrice}async getBlock(){const block=await this.provider.getBlock(this.blockHash);if(block==null){throw new Error("TODO")}return block}async getTransaction(){const tx=await this.provider.getTransaction(this.hash);if(tx==null){throw new Error("TODO")}return tx}async getResult(){return await this.provider.getTransactionResult(this.hash)}async confirmations(){return await this.provider.getBlockNumber()-this.blockNumber+1}removedEvent(){return createRemovedTransactionFilter(this)}reorderedEvent(other){assert(!other||other.isMined(),"unmined 'other' transction cannot be orphaned","UNSUPPORTED_OPERATION",{operation:"reorderedEvent(other)"});return createReorderedTransactionFilter(this,other)}}class TransactionResponse{provider;blockNumber;blockHash;index;hash;type;to;from;nonce;gasLimit;gasPrice;maxPriorityFeePerGas;maxFeePerGas;maxFeePerBlobGas;data;value;chainId;signature;accessList;blobVersionedHashes;#startBlock;constructor(tx,provider){this.provider=provider;this.blockNumber=tx.blockNumber!=null?tx.blockNumber:null;this.blockHash=tx.blockHash!=null?tx.blockHash:null;this.hash=tx.hash;this.index=tx.index;this.type=tx.type;this.from=tx.from;this.to=tx.to||null;this.gasLimit=tx.gasLimit;this.nonce=tx.nonce;this.data=tx.data;this.value=tx.value;this.gasPrice=tx.gasPrice;this.maxPriorityFeePerGas=tx.maxPriorityFeePerGas!=null?tx.maxPriorityFeePerGas:null;this.maxFeePerGas=tx.maxFeePerGas!=null?tx.maxFeePerGas:null;this.maxFeePerBlobGas=tx.maxFeePerBlobGas!=null?tx.maxFeePerBlobGas:null;this.chainId=tx.chainId;this.signature=tx.signature;this.accessList=tx.accessList!=null?tx.accessList:null;this.blobVersionedHashes=tx.blobVersionedHashes!=null?tx.blobVersionedHashes:null;this.#startBlock=-1}toJSON(){const{blockNumber,blockHash,index,hash,type,to,from,nonce,data,signature,accessList,blobVersionedHashes}=this;return{_type:"TransactionResponse",accessList:accessList,blockNumber:blockNumber,blockHash:blockHash,blobVersionedHashes:blobVersionedHashes,chainId:toJson(this.chainId),data:data,from:from,gasLimit:toJson(this.gasLimit),gasPrice:toJson(this.gasPrice),hash:hash,maxFeePerGas:toJson(this.maxFeePerGas),maxPriorityFeePerGas:toJson(this.maxPriorityFeePerGas),maxFeePerBlobGas:toJson(this.maxFeePerBlobGas),nonce:nonce,signature:signature,to:to,index:index,type:type,value:toJson(this.value)}}async getBlock(){let blockNumber=this.blockNumber;if(blockNumber==null){const tx=await this.getTransaction();if(tx){blockNumber=tx.blockNumber}}if(blockNumber==null){return null}const block=this.provider.getBlock(blockNumber);if(block==null){throw new Error("TODO")}return block}async getTransaction(){return this.provider.getTransaction(this.hash)}async confirmations(){if(this.blockNumber==null){const{tx,blockNumber}=await resolveProperties({tx:this.getTransaction(),blockNumber:this.provider.getBlockNumber()});if(tx==null||tx.blockNumber==null){return 0}return blockNumber-tx.blockNumber+1}const blockNumber=await this.provider.getBlockNumber();return blockNumber-this.blockNumber+1}async wait(_confirms,_timeout){const confirms=_confirms==null?1:_confirms;const timeout=_timeout==null?0:_timeout;let startBlock=this.#startBlock;let nextScan=-1;let stopScanning=startBlock===-1?true:false;const checkReplacement=async()=>{if(stopScanning){return null}const{blockNumber,nonce}=await resolveProperties({blockNumber:this.provider.getBlockNumber(),nonce:this.provider.getTransactionCount(this.from)});if(nonce<this.nonce){startBlock=blockNumber;return}if(stopScanning){return null}const mined=await this.getTransaction();if(mined&&mined.blockNumber!=null){return}if(nextScan===-1){nextScan=startBlock-3;if(nextScan<this.#startBlock){nextScan=this.#startBlock}}while(nextScan<=blockNumber){if(stopScanning){return null}const block=await this.provider.getBlock(nextScan,true);if(block==null){return}for(const hash of block){if(hash===this.hash){return}}for(let i=0;i<block.length;i++){const tx=await block.getTransaction(i);if(tx.from===this.from&&tx.nonce===this.nonce){if(stopScanning){return null}const receipt=await this.provider.getTransactionReceipt(tx.hash);if(receipt==null){return}if(blockNumber-receipt.blockNumber+1<confirms){return}let reason="replaced";if(tx.data===this.data&&tx.to===this.to&&tx.value===this.value){reason="repriced"}else if(tx.data==="0x"&&tx.from===tx.to&&tx.value===BN_0$1){reason="cancelled"}assert(false,"transaction was replaced","TRANSACTION_REPLACED",{cancelled:reason==="replaced"||reason==="cancelled",reason:reason,replacement:tx.replaceableTransaction(startBlock),hash:tx.hash,receipt:receipt})}}nextScan++}return};const checkReceipt=receipt=>{if(receipt==null||receipt.status!==0){return receipt}assert(false,"transaction execution reverted","CALL_EXCEPTION",{action:"sendTransaction",data:null,reason:null,invocation:null,revert:null,transaction:{to:receipt.to,from:receipt.from,data:""},receipt:receipt})};const receipt=await this.provider.getTransactionReceipt(this.hash);if(confirms===0){return checkReceipt(receipt)}if(receipt){if(await receipt.confirmations()>=confirms){return checkReceipt(receipt)}}else{await checkReplacement();if(confirms===0){return null}}const waiter=new Promise((resolve,reject)=>{const cancellers=[];const cancel=()=>{cancellers.forEach(c=>c())};cancellers.push(()=>{stopScanning=true});if(timeout>0){const timer=setTimeout(()=>{cancel();reject(makeError("wait for transaction timeout","TIMEOUT"))},timeout);cancellers.push(()=>{clearTimeout(timer)})}const txListener=async receipt=>{if(await receipt.confirmations()>=confirms){cancel();try{resolve(checkReceipt(receipt))}catch(error){reject(error)}}};cancellers.push(()=>{this.provider.off(this.hash,txListener)});this.provider.on(this.hash,txListener);if(startBlock>=0){const replaceListener=async()=>{try{await checkReplacement()}catch(error){if(isError(error,"TRANSACTION_REPLACED")){cancel();reject(error);return}}if(!stopScanning){this.provider.once("block",replaceListener)}};cancellers.push(()=>{this.provider.off("block",replaceListener)});this.provider.once("block",replaceListener)}});return await waiter}isMined(){return this.blockHash!=null}isLegacy(){return this.type===0}isBerlin(){return this.type===1}isLondon(){return this.type===2}isCancun(){return this.type===3}removedEvent(){assert(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"});return createRemovedTransactionFilter(this)}reorderedEvent(other){assert(this.isMined(),"unmined transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"});assert(!other||other.isMined(),"unmined 'other' transaction canot be orphaned","UNSUPPORTED_OPERATION",{operation:"removeEvent()"});return createReorderedTransactionFilter(this,other)}replaceableTransaction(startBlock){assertArgument(Number.isInteger(startBlock)&&startBlock>=0,"invalid startBlock","startBlock",startBlock);const tx=new TransactionResponse(this,this.provider);tx.#startBlock=startBlock;return tx}}function createReorderedTransactionFilter(tx,other){return{orphan:"reorder-transaction",tx:tx,other:other}}function createRemovedTransactionFilter(tx){return{orphan:"drop-transaction",tx:tx}}function createRemovedLogFilter(log){return{orphan:"drop-log",log:{transactionHash:log.transactionHash,blockHash:log.blockHash,blockNumber:log.blockNumber,address:log.address,data:log.data,topics:Object.freeze(log.topics.slice()),index:log.index}}}class EventLog extends Log{interface;fragment;args;constructor(log,iface,fragment){super(log,log.provider);const args=iface.decodeEventLog(fragment,log.data,log.topics);defineProperties(this,{args:args,fragment:fragment,interface:iface})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}class UndecodedEventLog extends Log{error;constructor(log,error){super(log,log.provider);defineProperties(this,{error:error})}}class ContractTransactionReceipt extends TransactionReceipt{#iface;constructor(iface,provider,tx){super(tx,provider);this.#iface=iface}get logs(){return super.logs.map(log=>{const fragment=log.topics.length?this.#iface.getEvent(log.topics[0]):null;if(fragment){try{return new EventLog(log,this.#iface,fragment)}catch(error){return new UndecodedEventLog(log,error)}}return log})}}class ContractTransactionResponse extends TransactionResponse{#iface;constructor(iface,provider,tx){super(tx,provider);this.#iface=iface}async wait(confirms,timeout){const receipt=await super.wait(confirms,timeout);if(receipt==null){return null}return new ContractTransactionReceipt(this.#iface,this.provider,receipt)}}class ContractUnknownEventPayload extends EventPayload{log;constructor(contract,listener,filter,log){super(contract,listener,filter);defineProperties(this,{log:log})}async getBlock(){return await this.log.getBlock()}async getTransaction(){return await this.log.getTransaction()}async getTransactionReceipt(){return await this.log.getTransactionReceipt()}}class ContractEventPayload extends ContractUnknownEventPayload{constructor(contract,listener,filter,fragment,_log){super(contract,listener,filter,new EventLog(_log,contract.interface,fragment));const args=contract.interface.decodeEventLog(fragment,this.log.data,this.log.topics);defineProperties(this,{args:args,fragment:fragment})}get eventName(){return this.fragment.name}get eventSignature(){return this.fragment.format()}}const BN_0=BigInt(0);function canCall(value){return value&&typeof value.call==="function"}function canEstimate(value){return value&&typeof value.estimateGas==="function"}function canResolve(value){return value&&typeof value.resolveName==="function"}function canSend(value){return value&&typeof value.sendTransaction==="function"}function getResolver(value){if(value!=null){if(canResolve(value)){return value}if(value.provider){return value.provider}}return undefined}class PreparedTopicFilter{#filter;fragment;constructor(contract,fragment,args){defineProperties(this,{fragment:fragment});if(fragment.inputs.length<args.length){throw new Error("too many arguments")}const runner=getRunner(contract.runner,"resolveName");const resolver=canResolve(runner)?runner:null;this.#filter=async function(){const resolvedArgs=await Promise.all(fragment.inputs.map((param,index)=>{const arg=args[index];if(arg==null){return null}return param.walkAsync(args[index],(type,value)=>{if(type==="address"){if(Array.isArray(value)){return Promise.all(value.map(v=>resolveAddress(v,resolver)))}return resolveAddress(value,resolver)}return value})}));return contract.interface.encodeFilterTopics(fragment,resolvedArgs)}()}getTopicFilter(){return this.#filter}}function getRunner(value,feature){if(value==null){return null}if(typeof value[feature]==="function"){return value}if(value.provider&&typeof value.provider[feature]==="function"){return value.provider}return null}function getProvider(value){if(value==null){return null}return value.provider||null}async function copyOverrides(arg,allowed){const _overrides=Typed.dereference(arg,"overrides");assertArgument(typeof _overrides==="object","invalid overrides parameter","overrides",arg);const overrides=copyRequest(_overrides);assertArgument(overrides.to==null||(allowed||[]).indexOf("to")>=0,"cannot override to","overrides.to",overrides.to);assertArgument(overrides.data==null||(allowed||[]).indexOf("data")>=0,"cannot override data","overrides.data",overrides.data);if(overrides.from){overrides.from=overrides.from}return overrides}async function resolveArgs(_runner,inputs,args){const runner=getRunner(_runner,"resolveName");const resolver=canResolve(runner)?runner:null;return await Promise.all(inputs.map((param,index)=>{return param.walkAsync(args[index],(type,value)=>{value=Typed.dereference(value,type);if(type==="address"){return resolveAddress(value,resolver)}return value})}))}function buildWrappedFallback(contract){const populateTransaction=async function(overrides){const tx=await copyOverrides(overrides,["data"]);tx.to=await contract.getAddress();if(tx.from){tx.from=await resolveAddress(tx.from,getResolver(contract.runner))}const iface=contract.interface;const noValue=getBigInt(tx.value||BN_0,"overrides.value")===BN_0;const noData=(tx.data||"0x")==="0x";if(iface.fallback&&!iface.fallback.payable&&iface.receive&&!noData&&!noValue){assertArgument(false,"cannot send data to receive or send value to non-payable fallback","overrides",overrides)}assertArgument(iface.fallback||noData,"cannot send data to receive-only contract","overrides.data",tx.data);const payable=iface.receive||iface.fallback&&iface.fallback.payable;assertArgument(payable||noValue,"cannot send value to non-payable fallback","overrides.value",tx.value);assertArgument(iface.fallback||noData,"cannot send data to receive-only contract","overrides.data",tx.data);return tx};const staticCall=async function(overrides){const runner=getRunner(contract.runner,"call");assert(canCall(runner),"contract runner does not support calling","UNSUPPORTED_OPERATION",{operation:"call"});const tx=await populateTransaction(overrides);try{return await runner.call(tx)}catch(error){if(isCallException(error)&&error.data){throw contract.interface.makeError(error.data,tx)}throw error}};const send=async function(overrides){const runner=contract.runner;assert(canSend(runner),"contract runner does not support sending transactions","UNSUPPORTED_OPERATION",{operation:"sendTransaction"});const tx=await runner.sendTransaction(await populateTransaction(overrides));const provider=getProvider(contract.runner);return new ContractTransactionResponse(contract.interface,provider,tx)};const estimateGas=async function(overrides){const runner=getRunner(contract.runner,"estimateGas");assert(canEstimate(runner),"contract runner does not support gas estimation","UNSUPPORTED_OPERATION",{operation:"estimateGas"});return await runner.estimateGas(await populateTransaction(overrides))};const method=async overrides=>{return await send(overrides)};defineProperties(method,{_contract:contract,estimateGas:estimateGas,populateTransaction:populateTransaction,send:send,staticCall:staticCall});return method}function buildWrappedMethod(contract,key){const getFragment=function(...args){const fragment=contract.interface.getFunction(key,args);assert(fragment,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:key,args:args}});return fragment};const populateTransaction=async function(...args){const fragment=getFragment(...args);let overrides={};if(fragment.inputs.length+1===args.length){overrides=await copyOverrides(args.pop());if(overrides.from){overrides.from=await resolveAddress(overrides.from,getResolver(contract.runner))}}if(fragment.inputs.length!==args.length){throw new Error("internal error: fragment inputs doesn't match arguments; should not happen")}const resolvedArgs=await resolveArgs(contract.runner,fragment.inputs,args);return Object.assign({},overrides,await resolveProperties({to:contract.getAddress(),data:contract.interface.encodeFunctionData(fragment,resolvedArgs)}))};const staticCall=async function(...args){const result=await staticCallResult(...args);if(result.length===1){return result[0]}return result};const send=async function(...args){const runner=contract.runner;assert(canSend(runner),"contract runner does not support sending transactions","UNSUPPORTED_OPERATION",{operation:"sendTransaction"});const tx=await runner.sendTransaction(await populateTransaction(...args));const provider=getProvider(contract.runner);return new ContractTransactionResponse(contract.interface,provider,tx)};const estimateGas=async function(...args){const runner=getRunner(contract.runner,"estimateGas");assert(canEstimate(runner),"contract runner does not support gas estimation","UNSUPPORTED_OPERATION",{operation:"estimateGas"});return await runner.estimateGas(await populateTransaction(...args))};const staticCallResult=async function(...args){const runner=getRunner(contract.runner,"call");assert(canCall(runner),"contract runner does not support calling","UNSUPPORTED_OPERATION",{operation:"call"});const tx=await populateTransaction(...args);let result="0x";try{result=await runner.call(tx)}catch(error){if(isCallException(error)&&error.data){throw contract.interface.makeError(error.data,tx)}throw error}const fragment=getFragment(...args);return contract.interface.decodeFunctionResult(fragment,result)};const method=async(...args)=>{const fragment=getFragment(...args);if(fragment.constant){return await staticCall(...args)}return await send(...args)};defineProperties(method,{name:contract.interface.getFunctionName(key),_contract:contract,_key:key,getFragment:getFragment,estimateGas:estimateGas,populateTransaction:populateTransaction,send:send,staticCall:staticCall,staticCallResult:staticCallResult});Object.defineProperty(method,"fragment",{configurable:false,enumerable:true,get:()=>{const fragment=contract.interface.getFunction(key);assert(fragment,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:key}});return fragment}});return method}function buildWrappedEvent(contract,key){const getFragment=function(...args){const fragment=contract.interface.getEvent(key,args);assert(fragment,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:key,args:args}});return fragment};const method=function(...args){return new PreparedTopicFilter(contract,getFragment(...args),args)};defineProperties(method,{name:contract.interface.getEventName(key),_contract:contract,_key:key,getFragment:getFragment});Object.defineProperty(method,"fragment",{configurable:false,enumerable:true,get:()=>{const fragment=contract.interface.getEvent(key);assert(fragment,"no matching fragment","UNSUPPORTED_OPERATION",{operation:"fragment",info:{key:key}});return fragment}});return method}const internal=Symbol.for("_ethersInternal_contract");const internalValues=new WeakMap;function setInternal(contract,values){internalValues.set(contract[internal],values)}function getInternal(contract){return internalValues.get(contract[internal])}function isDeferred(value){return value&&typeof value==="object"&&"getTopicFilter"in value&&typeof value.getTopicFilter==="function"&&value.fragment}async function getSubInfo(contract,event){let topics;let fragment=null;if(Array.isArray(event)){const topicHashify=function(name){if(isHexString(name,32)){return name}const fragment=contract.interface.getEvent(name);assertArgument(fragment,"unknown fragment","name",name);return fragment.topicHash};topics=event.map(e=>{if(e==null){return null}if(Array.isArray(e)){return e.map(topicHashify)}return topicHashify(e)})}else if(event==="*"){topics=[null]}else if(typeof event==="string"){if(isHexString(event,32)){topics=[event]}else{fragment=contract.interface.getEvent(event);assertArgument(fragment,"unknown fragment","event",event);topics=[fragment.topicHash]}}else if(isDeferred(event)){topics=await event.getTopicFilter()}else if("fragment"in event){fragment=event.fragment;topics=[fragment.topicHash]}else{assertArgument(false,"unknown event name","event",event)}topics=topics.map(t=>{if(t==null){return null}if(Array.isArray(t)){const items=Array.from(new Set(t.map(t=>t.toLowerCase())).values());if(items.length===1){return items[0]}items.sort();return items}return t.toLowerCase()});const tag=topics.map(t=>{if(t==null){return"null"}if(Array.isArray(t)){return t.join("|")}return t}).join("&");return{fragment:fragment,tag:tag,topics:topics}}async function hasSub(contract,event){const{subs}=getInternal(contract);return subs.get((await getSubInfo(contract,event)).tag)||null}async function getSub(contract,operation,event){const provider=getProvider(contract.runner);assert(provider,"contract runner does not support subscribing","UNSUPPORTED_OPERATION",{operation:operation});const{fragment,tag,topics}=await getSubInfo(contract,event);const{addr,subs}=getInternal(contract);let sub=subs.get(tag);if(!sub){const address=addr?addr:contract;const filter={address:address,topics:topics};const listener=log=>{let foundFragment=fragment;if(foundFragment==null){try{foundFragment=contract.interface.getEvent(log.topics[0])}catch(error){}}if(foundFragment){const _foundFragment=foundFragment;const args=fragment?contract.interface.decodeEventLog(fragment,log.data,log.topics):[];emit(contract,event,args,listener=>{return new ContractEventPayload(contract,listener,event,_foundFragment,log)})}else{emit(contract,event,[],listener=>{return new ContractUnknownEventPayload(contract,listener,event,log)})}};let starting=[];const start=()=>{if(starting.length){return}starting.push(provider.on(filter,listener))};const stop=async()=>{if(starting.length==0){return}let started=starting;starting=[];await Promise.all(started);provider.off(filter,listener)};sub={tag:tag,listeners:[],start:start,stop:stop};subs.set(tag,sub)}return sub}let lastEmit=Promise.resolve();async function _emit(contract,event,args,payloadFunc){await lastEmit;const sub=await hasSub(contract,event);if(!sub){return false}const count=sub.listeners.length;sub.listeners=sub.listeners.filter(({listener,once})=>{const passArgs=Array.from(args);if(payloadFunc){passArgs.push(payloadFunc(once?null:listener))}try{listener.call(contract,...passArgs)}catch(error){}return!once});if(sub.listeners.length===0){sub.stop();getInternal(contract).subs.delete(sub.tag)}return count>0}async function emit(contract,event,args,payloadFunc){try{await lastEmit}catch(error){}const resultPromise=_emit(contract,event,args,payloadFunc);lastEmit=resultPromise;return await resultPromise}const passProperties=["then"];class BaseContract{target;interface;runner;filters;[internal];fallback;constructor(target,abi,runner,_deployTx){assertArgument(typeof target==="string"||isAddressable(target),"invalid value for Contract target","target",target);if(runner==null){runner=null}const iface=Interface.from(abi);defineProperties(this,{target:target,runner:runner,interface:iface});Object.defineProperty(this,internal,{value:{}});let addrPromise;let addr=null;let deployTx=null;if(_deployTx){const provider=getProvider(runner);deployTx=new ContractTransactionResponse(this.interface,provider,_deployTx)}let subs=new Map;if(typeof target==="string"){if(isHexString(target)){addr=target;addrPromise=Promise.resolve(target)}else{const resolver=getRunner(runner,"resolveName");if(!canResolve(resolver)){throw makeError("contract runner does not support name resolution","UNSUPPORTED_OPERATION",{operation:"resolveName"})}addrPromise=resolver.resolveName(target).then(addr=>{if(addr==null){throw makeError("an ENS name used for a contract target must be correctly configured","UNCONFIGURED_NAME",{value:target})}getInternal(this).addr=addr;return addr})}}else{addrPromise=target.getAddress().then(addr=>{if(addr==null){throw new Error("TODO")}getInternal(this).addr=addr;return addr})}setInternal(this,{addrPromise:addrPromise,addr:addr,deployTx:deployTx,subs:subs});const filters=new Proxy({},{get:(target,prop,receiver)=>{if(typeof prop==="symbol"||passProperties.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}try{return this.getEvent(prop)}catch(error){if(!isError(error,"INVALID_ARGUMENT")||error.argument!=="key"){throw error}}return undefined},has:(target,prop)=>{if(passProperties.indexOf(prop)>=0){return Reflect.has(target,prop)}return Reflect.has(target,prop)||this.interface.hasEvent(String(prop))}});defineProperties(this,{filters:filters});defineProperties(this,{fallback:iface.receive||iface.fallback?buildWrappedFallback(this):null});return new Proxy(this,{get:(target,prop,receiver)=>{if(typeof prop==="symbol"||prop in target||passProperties.indexOf(prop)>=0){return Reflect.get(target,prop,receiver)}try{return target.getFunction(prop)}catch(error){if(!isError(error,"INVALID_ARGUMENT")||error.argument!=="key"){throw error}}return undefined},has:(target,prop)=>{if(typeof prop==="symbol"||prop in target||passProperties.indexOf(prop)>=0){return Reflect.has(target,prop)}return target.interface.hasFunction(prop)}})}connect(runner){return new BaseContract(this.target,this.interface,runner)}attach(target){return new BaseContract(target,this.interface,this.runner)}async getAddress(){return await getInternal(this).addrPromise}async getDeployedCode(){const provider=getProvider(this.runner);assert(provider,"runner does not support .provider","UNSUPPORTED_OPERATION",{operation:"getDeployedCode"});const code=await provider.getCode(await this.getAddress());if(code==="0x"){return null}return code}async waitForDeployment(){const deployTx=this.deploymentTransaction();if(deployTx){await deployTx.wait();return this}const code=await this.getDeployedCode();if(code!=null){return this}const provider=getProvider(this.runner);assert(provider!=null,"contract runner does not support .provider","UNSUPPORTED_OPERATION",{operation:"waitForDeployment"});return new Promise((resolve,reject)=>{const checkCode=async()=>{try{const code=await this.getDeployedCode();if(code!=null){return resolve(this)}provider.once("block",checkCode)}catch(error){reject(error)}};checkCode()})}deploymentTransaction(){return getInternal(this).deployTx}getFunction(key){if(typeof key!=="string"){key=key.format()}const func=buildWrappedMethod(this,key);return func}getEvent(key){if(typeof key!=="string"){key=key.format()}return buildWrappedEvent(this,key)}async queryTransaction(hash){throw new Error("@TODO")}async queryFilter(event,fromBlock,toBlock){if(fromBlock==null){fromBlock=0}if(toBlock==null){toBlock="latest"}const{addr,addrPromise}=getInternal(this);const address=addr?addr:await addrPromise;const{fragment,topics}=await getSubInfo(this,event);const filter={address:address,topics:topics,fromBlock:fromBlock,toBlock:toBlock};const provider=getProvider(this.runner);assert(provider,"contract runner does not have a provider","UNSUPPORTED_OPERATION",{operation:"queryFilter"});return(await provider.getLogs(filter)).map(log=>{let foundFragment=fragment;if(foundFragment==null){try{foundFragment=this.interface.getEvent(log.topics[0])}catch(error){}}if(foundFragment){try{return new EventLog(log,this.interface,foundFragment)}catch(error){return new UndecodedEventLog(log,error)}}return new Log(log,provider)})}async on(event,listener){const sub=await getSub(this,"on",event);sub.listeners.push({listener:listener,once:false});sub.start();return this}async once(event,listener){const sub=await getSub(this,"once",event);sub.listeners.push({listener:listener,once:true});sub.start();return this}async emit(event,...args){return await emit(this,event,args,null)}async listenerCount(event){if(event){const sub=await hasSub(this,event);if(!sub){return 0}return sub.listeners.length}const{subs}=getInternal(this);let total=0;for(const{listeners}of subs.values()){total+=listeners.length}return total}async listeners(event){if(event){const sub=await hasSub(this,event);if(!sub){return[]}return sub.listeners.map(({listener})=>listener)}const{subs}=getInternal(this);let result=[];for(const{listeners}of subs.values()){result=result.concat(listeners.map(({listener})=>listener))}return result}async off(event,listener){const sub=await hasSub(this,event);if(!sub){return this}if(listener){const index=sub.listeners.map(({listener})=>listener).indexOf(listener);if(index>=0){sub.listeners.splice(index,1)}}if(listener==null||sub.listeners.length===0){sub.stop();getInternal(this).subs.delete(sub.tag)}return this}async removeAllListeners(event){if(event){const sub=await hasSub(this,event);if(!sub){return this}sub.stop();getInternal(this).subs.delete(sub.tag)}else{const{subs}=getInternal(this);for(const{tag,stop}of subs.values()){stop();subs.delete(tag)}}return this}async addListener(event,listener){return await this.on(event,listener)}async removeListener(event,listener){return await this.off(event,listener)}static buildClass(abi){class CustomContract extends BaseContract{constructor(address,runner=null){super(address,abi,runner)}}return CustomContract}static from(target,abi,runner){if(runner==null){runner=null}const contract=new this(target,abi,runner);return contract}}function _ContractBase(){return BaseContract}class Contract extends _ContractBase(){}class ContractFactory{interface;bytecode;runner;constructor(abi,bytecode,runner){const iface=Interface.from(abi);if(bytecode instanceof Uint8Array){bytecode=hexlify(getBytes(bytecode))}else{if(typeof bytecode==="object"){bytecode=bytecode.object}if(!bytecode.startsWith("0x")){bytecode="0x"+bytecode}bytecode=hexlify(getBytes(bytecode))}defineProperties(this,{bytecode:bytecode,interface:iface,runner:runner||null})}attach(target){return new BaseContract(target,this.interface,this.runner)}async getDeployTransaction(...args){let overrides={};const fragment=this.interface.deploy;if(fragment.inputs.length+1===args.length){overrides=await copyOverrides(args.pop())}if(fragment.inputs.length!==args.length){throw new Error("incorrect number of arguments to constructor")}const resolvedArgs=await resolveArgs(this.runner,fragment.inputs,args);const data=concat([this.bytecode,this.interface.encodeDeploy(resolvedArgs)]);return Object.assign({},overrides,{data:data})}async deploy(...args){const tx=await this.getDeployTransaction(...args);assert(this.runner&&typeof this.runner.sendTransaction==="function","factory runner does not support sending transactions","UNSUPPORTED_OPERATION",{operation:"sendTransaction"});const sentTx=await this.runner.sendTransaction(tx);const address=getCreateAddress(sentTx);return new BaseContract(address,this.interface,this.runner,sentTx)}connect(runner){return new ContractFactory(this.interface,this.bytecode,runner)}static fromSolidity(output,runner){assertArgument(output!=null,"bad compiler output","output",output);if(typeof output==="string"){output=JSON.parse(output)}const abi=output.abi;let bytecode="";if(output.bytecode){bytecode=output.bytecode}else if(output.evm&&output.evm.bytecode){bytecode=output.evm.bytecode}return new this(abi,bytecode,runner)}}const _abi=[{inputs:[{internalType:"address",name:"book_",type:"address"},{internalType:"uint256",name:"blocksPerEpoch_",type:"uint256"},{internalType:"uint256",name:"deployDelay_",type:"uint256"}],stateMutability:"nonpayable",type:"constructor"},{inputs:[],name:"InvalidSubmission",type:"error"},{anonymous:false,inputs:[{indexed:true,internalType:"address",name:"sender",type:"address"},{indexed:true,internalType:"uint256",name:"index",type:"uint256"},{indexed:false,internalType:"bytes32",name:"startMerkleRoot",type:"bytes32"},{indexed:false,internalType:"uint256",name:"submissionIndex",type:"uint256"},{indexed:false,internalType:"uint256",name:"flowLength",type:"uint256"},{indexed:false,internalType:"bytes32",name:"context",type:"bytes32"}],name:"NewEpoch",type:"event"},{anonymous:false,inputs:[{indexed:false,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},{anonymous:false,inputs:[{indexed:true,internalType:"address",name:"sender",type:"address"},{indexed:true,internalType:"bytes32",name:"identity",type:"bytes32"},{indexed:false,internalType:"uint256",name:"submissionIndex",type:"uint256"},{indexed:false,internalType:"uint256",name:"startPos",type:"uint256"},{indexed:false,internalType:"uint256",name:"length",type:"uint256"},{components:[{internalType:"uint256",name:"length",type:"uint256"},{internalType:"bytes",name:"tags",type:"bytes"},{components:[{internalType:"bytes32",name:"root",type:"bytes32"},{internalType:"uint256",name:"height",type:"uint256"}],internalType:"struct SubmissionNode[]",name:"nodes",type:"tuple[]"}],indexed:false,internalType:"struct Submission",name:"submission",type:"tuple"}],name:"Submit",type:"event"},{anonymous:false,inputs:[{indexed:false,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"},{inputs:[{components:[{internalType:"uint256",name:"length",type:"uint256"},{internalType:"bytes",name:"tags",type:"bytes"},{components:[{internalType:"bytes32",name:"root",type:"bytes32"},{internalType:"uint256",name:"height",type:"uint256"}],internalType:"struct SubmissionNode[]",name:"nodes",type:"tuple[]"}],internalType:"struct Submission[]",name:"submissions",type:"tuple[]"}],name:"batchSubmit",outputs:[{internalType:"uint256[]",name:"indexes",type:"uint256[]"},{internalType:"bytes32[]",name:"digests",type:"bytes32[]"},{internalType:"uint256[]",name:"startIndexes",type:"uint256[]"},{internalType:"uint256[]",name:"lengths",type:"uint256[]"}],stateMutability:"payable",type:"function"},{inputs:[],name:"blocksPerEpoch",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"book",outputs:[{internalType:"contract AddressBook",name:"",type:"address"}],stateMutability:"view",type:"function"},{inputs:[],name:"commitRoot",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"currentLength",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"epoch",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"epochStartPosition",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"firstBlock",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"getContext",outputs:[{components:[{internalType:"uint256",name:"epoch",type:"uint256"},{internalType:"uint256",name:"mineStart",type:"uint256"},{internalType:"bytes32",name:"flowRoot",type:"bytes32"},{internalType:"uint256",name:"flowLength",type:"uint256"},{internalType:"bytes32",name:"blockDigest",type:"bytes32"},{internalType:"bytes32",name:"digest",type:"bytes32"}],internalType:"struct MineContext",name:"",type:"tuple"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"bytes32",name:"digest",type:"bytes32"}],name:"getEpochRange",outputs:[{components:[{internalType:"uint128",name:"start",type:"uint128"},{internalType:"uint128",name:"end",type:"uint128"}],internalType:"struct EpochRange",name:"",type:"tuple"}],stateMutability:"view",type:"function"},{inputs:[],name:"makeContext",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"uint256",name:"cnt",type:"uint256"}],name:"makeContextFixedTimes",outputs:[],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"makeContextWithResult",outputs:[{components:[{internalType:"uint256",name:"epoch",type:"uint256"},{internalType:"uint256",name:"mineStart",type:"uint256"},{internalType:"bytes32",name:"flowRoot",type:"bytes32"},{internalType:"uint256",name:"flowLength",type:"uint256"},{internalType:"bytes32",name:"blockDigest",type:"bytes32"},{internalType:"bytes32",name:"digest",type:"bytes32"}],internalType:"struct MineContext",name:"",type:"tuple"}],stateMutability:"nonpayable",type:"function"},{inputs:[{internalType:"uint256",name:"_length",type:"uint256"},{internalType:"uint256",name:"alignExp",type:"uint256"}],name:"nextAlign",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},{inputs:[{internalType:"uint256",name:"_length",type:"uint256"}],name:"nextPow2",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function"},{inputs:[],name:"numSubmissions",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint128",name:"targetPosition",type:"uint128"}],name:"queryContextAtPosition",outputs:[{components:[{internalType:"uint128",name:"start",type:"uint128"},{internalType:"uint128",name:"end",type:"uint128"},{internalType:"bytes32",name:"digest",type:"bytes32"}],internalType:"struct EpochRangeWithContextDigest",name:"range",type:"tuple"}],stateMutability:"nonpayable",type:"function"},{inputs:[],name:"root",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},{inputs:[],name:"rootHistory",outputs:[{internalType:"contract IDigestHistory",name:"",type:"address"}],stateMutability:"view",type:"function"},{inputs:[],name:"submissionIndex",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{components:[{internalType:"uint256",name:"length",type:"uint256"},{internalType:"bytes",name:"tags",type:"bytes"},{components:[{internalType:"bytes32",name:"root",type:"bytes32"},{internalType:"uint256",name:"height",type:"uint256"}],internalType:"struct SubmissionNode[]",name:"nodes",type:"tuple[]"}],internalType:"struct Submission",name:"submission",type:"tuple"}],name:"submit",outputs:[{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes32",name:"",type:"bytes32"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"payable",type:"function"},{inputs:[],name:"unstagedHeight",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},{inputs:[{internalType:"uint256",name:"height",type:"uint256"}],name:"zeros",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"pure",type:"function"}];const _bytecode="0x6101006040523480156200001257600080fd5b506040516200353b3803806200353b833981016040819052620000359162000246565b6000805460ff1916815560018055604080518281526020810191829052516200006191600291620001d1565b50600280546001818101835560009283527f405787fa12a823e0f2b7631cc41b3ba8828b3321ca811111fa75cd3aa3bb5ace9091019290925560039190915560055560c0829052604051601490620000b99062000221565b908152602001604051809103906000f080158015620000dc573d6000803e3d6000fd5b506001600160a01b031660a052620000f58143620002a1565b60e09081526001600160a01b0384166080526040805160c081018252600081529151602083015281016200012862000198565b815260016020808301919091527fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a4706040808401829052606093840191909152835160075590830151600855820151600955810151600a556080810151600b5560a00151600c5550620002e9915050565b6002805460009190620001ae90600190620002bd565b81548110620001c157620001c1620002d3565b9060005260206000200154905090565b8280548282559060005260206000209081019282156200020f579160200282015b828111156200020f578251825591602001919060010190620001f2565b506200021d9291506200022f565b5090565b6106718062002eca83390190565b5b808211156200021d576000815560010162000230565b6000806000606084860312156200025c57600080fd5b83516001600160a01b03811681146200027457600080fd5b602085015160409095015190969495509392505050565b634e487b7160e01b600052601160045260246000fd5b80820180821115620002b757620002b76200028b565b92915050565b81810381811115620002b757620002b76200028b565b634e487b7160e01b600052603260045260246000fd5b60805160a05160c05160e051612b686200036260003960008181610236015281816105ce015281816107e8015281816108cb01528181610b28015281816118d50152611a2b01526000818161053b0152611a0301526000818161048a0152611a92015260008181610162015261208e0152612b686000f3fe60806040526004361061014b5760003560e01c8063900cf0cf116100b6578063c7dd52211161006f578063c7dd522114610478578063d34353c9146104ac578063e8295588146104c1578063ebf0c717146104e1578063ef3e12dc146104f6578063f06820541461052957600080fd5b8063900cf0cf146103e857806393e405a0146103fe5780639e62a38e14610414578063a3d35f3614610437578063b464b53e1461044d578063b8a409ac1461046257600080fd5b806338d45e101161010857806338d45e10146102cc5780633d75d9c2146102e1578063555430a1146103015780635c975abb1461032157806377e19824146103445780637d5907081461035957600080fd5b806305a8da7214610150578063127f0f07146101a157806318a641ef14610202578063231b02681461022457806331bae17414610266578063364800ec146102b6575b600080fd5b34801561015c57600080fd5b506101847f000000000000000000000000000000000000000000000000000000000000000081565b6040516001600160a01b0390911681526020015b60405180910390f35b3480156101ad57600080fd5b506101b661055d565b6040516101989190600060c082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015292915050565b34801561020e57600080fd5b5061022261021d3660046124d7565b6105cc565b005b34801561023057600080fd5b506102587f000000000000000000000000000000000000000000000000000000000000000081565b604051908152602001610198565b34801561027257600080fd5b506102866102813660046124f0565b610643565b6040805182516001600160801b039081168252602080850151909116908201529181015190820152606001610198565b3480156102c257600080fd5b5061025860035481565b3480156102d857600080fd5b506102226107e6565b3480156102ed57600080fd5b506102586102fc3660046124d7565b610835565b34801561030d57600080fd5b5061025861031c366004612519565b610881565b34801561032d57600080fd5b5060005460ff166040519015158152602001610198565b34801561035057600080fd5b50600454610258565b34801561036557600080fd5b506103c16103743660046124d7565b6040805180820190915260008082526020820152506000908152600d60209081526040918290208251808401909352546001600160801b038082168452600160801b909104169082015290565b6040805182516001600160801b039081168252602093840151169281019290925201610198565b3480156103f457600080fd5b5061025860055481565b34801561040a57600080fd5b5061025860065481565b61042761042236600461274e565b6108bb565b604051610198949392919061283a565b34801561044357600080fd5b5061025860015481565b34801561045957600080fd5b506101b6610af4565b34801561046e57600080fd5b5061025860045481565b34801561048457600080fd5b506101847f000000000000000000000000000000000000000000000000000000000000000081565b3480156104b857600080fd5b50610222610b7b565b3480156104cd57600080fd5b506102586104dc3660046124d7565b610c92565b3480156104ed57600080fd5b50610258611891565b6105096105043660046128b9565b6118c5565b604080519485526020850193909352918301526060820152608001610198565b34801561053557600080fd5b506102587f000000000000000000000000000000000000000000000000000000000000000081565b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a0810191909152506040805160c0810182526007548152600854602082015260095491810191909152600a546060820152600b546080820152600c5460a082015290565b7f00000000000000000000000000000000000000000000000000000000000000004310156106155760405162461bcd60e51b815260040161060c906128f6565b60405180910390fd5b60005b81811161063f576106276119fe565b61062f575050565b61063881612943565b9050610618565b5050565b60408051606081018252600080825260208201819052918101919091526106686107e6565b600154826001600160801b0316106106ce5760405162461bcd60e51b8152602060048201526024808201527f5175657269656420706f736974696f6e206578636565647320757070657220626044820152631bdd5b9960e21b606482015260840161060c565b600e546000905b8181111561079e57600060026106eb848461295c565b6106f59190612985565b9050600e818154811061070a5761070a612999565b600091825260209182902060408051606081018252600290930290910180546001600160801b038082168552600160801b90910481169484018590526001909101549183019190915290955086161061076f5761076881600161295c565b9250610798565b83600001516001600160801b0316856001600160801b03161061079457505050919050565b8091505b506106d5565b60405162461bcd60e51b815260206004820152601b60248201527f43616e206e6f742066696e642070726f70657220636f6e746578740000000000604482015260640161060c565b7f00000000000000000000000000000000000000000000000000000000000000004310156108265760405162461bcd60e51b815260040161060c906128f6565b61082e6119fe565b610826575b565b6000818082036108485750600092915050565b600181811c909117600281901c17600481901c17600881901c17601081901c17602081901c179061087a90829061295c565b9392505050565b6000828082036108955760009150506108b5565b6108a06001826129af565b831c90506108af60018261295c565b831b9150505b92915050565b6060806060806108c9611d1f565b7f00000000000000000000000000000000000000000000000000000000000000004310156109095760405162461bcd60e51b815260040161060c906128f6565b84518067ffffffffffffffff8111156109245761092461253b565b60405190808252806020026020018201604052801561094d578160200160208202803683370190505b5094508067ffffffffffffffff8111156109695761096961253b565b604051908082528060200260200182016040528015610992578160200160208202803683370190505b5093508067ffffffffffffffff8111156109ae576109ae61253b565b6040519080825280602002602001820160405280156109d7578160200160208202803683370190505b5092508067ffffffffffffffff8111156109f3576109f361253b565b604051908082528060200260200182016040528015610a1c578160200160208202803683370190505b50915060005b81811015610aeb57600080600080610a528b8681518110610a4557610a45612999565b60200260200101516118c5565b9350935093509350838a8681518110610a6d57610a6d612999565b60200260200101818152505082898681518110610a8c57610a8c612999565b60200260200101818152505081888681518110610aab57610aab612999565b60200260200101818152505080878681518110610aca57610aca612999565b6020026020010181815250505050505080610ae490612943565b9050610a22565b50509193509193565b6040805160c081018252600080825260208201819052918101829052606081018290526080810182905260a08101919091527f0000000000000000000000000000000000000000000000000000000000000000431015610b665760405162461bcd60e51b815260040161060c906128f6565b610b6e6107e6565b610b7661055d565b905090565b60025460035403610b8857565b600280546003549091600091610ba0906001906129af565b81548110610bb057610bb0612999565b906000526020600020015490506000610bd160016003546104dc91906129af565b6003549091505b83811015610c8a5760408051602080820186905281830185905282518083038401815260609092019092528051910120600154610c1990600290841c6129c2565b600003610c5357809350610c2c82610c92565b92508060028381548110610c4257610c42612999565b600091825260209091200155610c77565b60028281548110610c6657610c66612999565b906000526020600020015493508092505b5080610c8281612943565b915050610bd8565b505050600355565b600081600003610cc357507fd397b3b043d87fcd6fad1291ff0bfd16401c274896d8c63a923727f077b8e0b5919050565b81600103610cf257507ff73e6947d7d1628b9976a6e40d7b278a8a16405e96324a68df45b12a51b7cfde919050565b81600203610d2157507fa1520264ae93cac619e22e8718fc4fa7ebdd23f493cad602434d2a58ff4868fb919050565b81600303610d5057507fde5747106ac1194a1fa9071dbd6cf19dc2bc7964497ef0afec7e4bdbcf08c47e919050565b81600403610d7f57507f09c7082879180d28c789c05fafe7030871c76cedbe82c948b165d6a1d66ac15b919050565b81600503610dae57507faa7a02bcf29fba687f84123c808b5b48834ff5395abe98e622fadc14e4180c95919050565b81600603610ddd57507f7608fd46b710b589e0f2ee5a13cd9c41d432858a30d524f84c6d5db37f66273a919050565b81600703610e0c57507fa5d9a2f7f3573ac9a1366bc484688b4daf934b87ea9b3bf2e703da8fd9f09708919050565b81600803610e3b57507f6c1779477f4c3fca26b4607398859a43b90a286ce8062500744bd4949981757f919050565b81600903610e6a57507f45c22df3d952c33d5edce122eed85e5cda3fd61939e7ad7b3e03b6927bb598ea919050565b81600a03610e9957507fe68d02859bb6211cec64f52368b77d422de3b8eac34bf615942b814b643301b5919050565b81600b03610ec857507f62d78399b954d51cb9728601738ad13ddc43b2300064660716bb661d2f4d686f919050565b81600c03610ef757507f6e250d9abdbbb3993fce08de0395cdb56f0483e67d8762a798de011f6a50866a919050565b81600d03610f2657507f1d1a3a74062fd94078617e33eb901eaf16a830f67c387d8eed342db2ac5e2cc5919050565b81600e03610f5557507f19b3b3886526917eae8650223d0be20a0301be960eb339696e673ad8a804440f919050565b81600f03610f8457507fee9e05df53f10e62a897e5140a3f58732dd849e69cd1d62b21ed80ead711a014919050565b81601003610fb357507f2cc7aa6e611a113a34505dc1c96b220f14909b70e2c2c7b1a74655da21013c5e919050565b81601103610fe257507f949b52dfece7ca3bad3cb27f7750ecaee64cedb6243a275c35984e92956c530a919050565b8160120361101157507fb2680d060b763b932c150434c3812ba9fbc50937e0ebcf5758de884be81bab65919050565b8160130361104057507f523aebf4a085edbc9c8cdc99c83f46262e5f029b395ff7bf561a48a3f387e6b8919050565b8160140361106f57507fc9ab73827ab33c0cedb7ecf0ed2e6e32583c0fe887133a7f381ea4ba84d95b76919050565b8160150361109e57507f23eb397dec7e564ebe97f160a5e1081a77d9861f316807079b6be4731beb331e919050565b816016036110cd57507fdfa44a274c60f090df034aaf75539fd40e94cfd6362dd53d26ed20c8ad529563919050565b816017036110fc57507f15b13ee358e1044a53381243c094e54bf7aceb9b5325a0313d6b85fd44e8b3a5919050565b8160180361112b57507f1a7a93871e2daa0f1860aa91d4ece4ccd012dac5fe581176a21b155cfeca6d40919050565b8160190361115a57507fb12665fd0b884a7c7d1e0294d369170d7e672d9e125eb87784556305f98292df919050565b81601a0361118957507f2a5543b0b2f8cf550524390291774f4d6c8c0a25ff5393b09c44d75c92a5bd8e919050565b81601b036111b857507ff9df1841a6e7164b67a1242f1c74975137085ffd9721831f6c469d3a4d5ba42e919050565b81601c036111e757507fba24736b1b48246c1f7803be967be43ca0dddc9c2c0687a2957952249bc89371919050565b81601d0361121657507ff3f706b73790c73ca0a8f0460ac3a2a102e280415586b520e70cd5e8264388b4919050565b81601e0361124557507fc1f5a9a9f357e1c37814688cf7290c87a264ed3d6174a12b978da1c586f53825919050565b81601f0361127457507f766f7702e19ce23d426cdad03e4292a5a42c4669420101fed74400ec7cda3ac6919050565b816020036112a357507f070fec213e105b3e4d9b0434ac2fc7ca721d35093dc741fb9419797003e2394a919050565b816021036112d257507f9a7aade05b49e43f5fd3782571cc8c90eadacd5d660b53842b4e5b63d675ae0c919050565b8160220361130157507fb27b35a8236d0f9b6692820429c025ed58ed378dc98d316b762f0c865c68be6f919050565b8160230361133057507fdc567ad38d9b90cc9bea4e0f82ec05eca10b3aa94eddc7b63c4fd20c001bb53b919050565b8160240361135f57507fb208dfc457c8b30661ae49544c8e57399818095aab8dd7a426fb8dd56bb8c559919050565b8160250361138e57507fc4a72e1ff84f7a22631f3f95c61c392f98f52050360215a9d7e75d79b0bcd2ca919050565b816026036113bd57507fbb093ec8c0d7defb1de668b5b5dd4f2619e5cd92d29cc144862364a83ab993a8919050565b816027036113ec57507fe341796f2fe3975012c1e6badfa2e9c4523e43f911dc845082c3f4d7b4ff871d919050565b8160280361141b57507f42d356a11a0b39243eca3c3263299cb6f8c3e9728af6d9d8b0ddb6d354f1890d919050565b8160290361144a57507f0ce506e834e3a50a33f80074bc7fa16cf3c0712b36a41b69699177ea25de6c30919050565b81602a0361147957507fd8fa5bf130aeb7756b1ed09090cc80ed78dae0617978540f0fabd06dfb978938919050565b81602b036114a857507feed69a20fe36eb604f2153efa3b01c0e143cdf02229a1b8f741c9c2719059eb0919050565b81602c036114d757507f303c9c566ebf5bfe252796e5c131a99801226152a514688b5ca6883e99031d88919050565b81602d0361150657507fc7c3765ba96cfbccf3ae718393fa89791070cc8cd85f280b6ac46aea10d96042919050565b81602e0361153557507f1ca65b0a2b8034ee6bfb1fa4526832304e393af835c2c42b4dace58048746800919050565b81602f0361156457507f957add5e02350fd47de3a8e1da38fd774ceb31214d5897ed6315740a83cd634a919050565b8160300361159357507f787892cb439d5d358870774e163557cf02ec3cb87be6fde11abf1acee14eeaa4919050565b816031036115c257507f047c0962d4f5c8f60692c587de07739528c4d2059240d61dd34d2a547a438ee6919050565b816032036115f157507fc18727efc9e4df63020dcd90edc17dfd2ad14f02328c912b13898e0b53735556919050565b8160330361162057507fe38b9218987e451effe1648c3c9851ad03b64b052a5a3f5ca30f4d7b1ecf7120919050565b8160340361164f57507f0e48ecb1a5418e6218289acc8cf723e67ac6eae3ecb80f644336ab4365a2f2b2919050565b8160350361167e57507fd60e66f5b8cd08d71a1a4d7798952a7afa5a6e93a886c587a46a5500ebef4a60919050565b816036036116ad57507f5162aa9c31d9105f689cf6e71e19548bc9f0218b7d0f99ff7fa8bc2f19c68462919050565b816037036116dc57507f6fa8519b4b0e8fb97a9b618e97627d97b9b9d29d04521fd96472e9c502700568919050565b8160380361170b57507f41f5dcf0cdee270a2ad9a5f8130aaaab94b237463e09757c28b0321f09e24eb0919050565b8160390361173a57507f87a119239fa90732197108adfd029938b4743874d959d3da79b3a30f4832899e919050565b81603a0361176957507f8e96dbaa5c72e84a5297b040ccc1a60750a3201166e3b7740d352837233608a1919050565b81603b0361179857507f01605058d167ce967af8c475d2f6c341c3e0b437babf899c9da73a520aa4ecb5919050565b81603c036117c757507f04529eb80532c5118949d700d8dfd2aa86850b1c6479b26276b9486784a145ff919050565b81603d036117f657507fd191814ad13f27361ae20a46cbac8f6e76c10ebe9af0806d6720492ee2f296f0919050565b81603e0361182557507fa28df63f78821060570da371c0be1312188346b92a7965cc4b980b26c134a4d7919050565b81603f0361185457507fb48a92d40b61dc995ceecee4cded6415050dcece448b1e0b5e5b6a0e6981f3ef919050565b60405162461bcd60e51b8152602060048201526012602482015271125b99195e081bdd5d081bd988189bdd5b9960721b604482015260640161060c565b60028054600091906118a5906001906129af565b815481106118b5576118b5612999565b9060005260206000200154905090565b6000806000806118d3611d1f565b7f00000000000000000000000000000000000000000000000000000000000000004310156119135760405162461bcd60e51b815260040161060c906128f6565b61191c85611d65565b61195d5760405162461bcd60e51b815260206004820152601260248201527124b73b30b634b21039bab136b4b9b9b4b7b760711b604482015260640161060c565b600061196886611f7c565b90506119726107e6565b600061197d87611fda565b9050600061198a88612180565b6004805491925060019060006119a0838561295c565b9250508190555081336001600160a01b03167f167ce04d2aa1981994d3a31695da0d785373335b1078cec239a1a3a2c76755558386888e6040516119e79493929190612a11565b60405180910390a396509450925090509193509193565b6000807f0000000000000000000000000000000000000000000000000000000000000000600554600101027f0000000000000000000000000000000000000000000000000000000000000000019050438110611a5c57600091505090565b611a64610b7b565b6000611a6e611891565b604051632d287e4360e01b8152600481018290529091506000906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690632d287e43906024016020604051808303816000875af1158015611adb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611aff9190612aa8565b90506005548114611b1257611b12612ac1565b60008043611b228661010061295c565b1015611b5257507fc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470905080611c60565b506001546040805186406020820181905291810186905260608101929092529060800160408051808303601f190181528282528051602091820120600680546001805487870187526001600160801b039283168089529083168689018181526000878152600d89528981209a519151918616600160801b928716830217909a558851606081018a52928352968201908152968101858152600e8054808501825599529051965196831696909216909402949094177fbb7b4a454dc3493923482f07822329ed19e8244eff582cc204f8554c3620c3fd60029096029586015592517fbb7b4a454dc3493923482f07822329ed19e8244eff582cc204f8554c3620c3fe9094019390935554905591505b600160056000828254611c73919061295c565b90915550506040805160c08101825260055480825260208083018990528284018890526001546060808501829052608080860188905260a0909501889052600784905560088b905560098a9055600a829055600b879055600c88905560045486518b815293840152948201529283018590529133917fbc8a3fd82465d43f1709e44ed882f7e1af0147274196ef1ec009f5d52ff4e993910160405180910390a360019550505050505090565b60005460ff16156108335760405162461bcd60e51b815260206004820152601060248201526f14185d5cd8589b194e881c185d5cd95960821b604482015260640161060c565b6000816040015151600003611d7c57506000919050565b6040820151805160049190611d93906001906129af565b81518110611da357611da3612999565b6020026020010151602001518360400151600081518110611dc657611dc6612999565b602002602001015160200151611ddc91906129af565b10611de957506000919050565b60408260400151600081518110611e0257611e02612999565b60200260200101516020015110611e1b57506000919050565b60005b6001836040015151611e3091906129af565b811015611ea75782604001518181518110611e4d57611e4d612999565b6020026020010151602001518360400151826001611e6b919061295c565b81518110611e7b57611e7b612999565b60200260200101516020015110611e955750600092915050565b80611e9f81612943565b915050611e1e565b506000611eb383611f7c565b9050611ec161010082612ad7565b83511115611ed25750600092915050565b60006010821015611eef57611ee86001836129af565b9050611f55565b836040015151600103611f0a57611ee8600483901c836129af565b60048460400151600081518110611f2357611f23612999565b602002602001015160200151611f3991906129af565b611f4490600161295c565b611f52906001901b836129af565b90505b611f6161010082612ad7565b845111611f72575060009392505050565b5060019392505050565b600080805b836040015151811015611fd35783604001518181518110611fa457611fa4612999565b6020026020010151602001516001901b82611fbf919061295c565b915080611fcb81612943565b915050611f81565b5092915050565b600154600090815b83604001515181101561206b5760008460400151828151811061200757612007612999565b602002602001015160000151905060008560400151838151811061202d5761202d612999565b6020026020010151602001519050600061204783836121b4565b905083600003612055578095505b505050808061206390612943565b915050611fe2565b50600061207882846129af565b905060008360015461208a91906129af565b90507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166380f556056040518163ffffffff1660e01b8152600401602060405180830381865afa1580156120ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061210e9190612af6565b604051636d3759b560e11b81526004810185905260248101839052604481018490526001600160a01b03919091169063da6eb36a90606401600060405180830381600087803b15801561216057600080fd5b505af1158015612174573d6000803e3d6000fd5b50505050505050919050565b600081604001516040516020016121979190612b1f565b604051602081830303815290604052805190602001209050919050565b6000806121c360015484610881565b905060006121d46001851b8361295c565b6002549091506121e6906001906129af565b6001901b81111561222f576121f9610b7b565b612201612324565b600254612210906001906129af565b6001901b81111561222857612223612324565b612201565b6002546003555b60025461223b856123b2565b60008087875b8481101561230657612256600288831c6129c2565b60000361229c57816002828154811061227157612271612999565b60009182526020909120015561228881600161295c565b6003556122966001866129af565b50612306565b600281815481106122af576122af612999565b9060005260206000200154935081925083836040516020016122db929190918252602082015260400190565b60405160208183030381529060405280519060200120915080806122fe90612943565b915050612241565b506123146001891b8761295c565b6001555093979650505050505050565b60028054906000906123376001846129af565b8154811061234757612347612999565b600091825260208220015491506123626104dc6001856129af565b905060028282604051602001612382929190918252602082015260400190565b60408051601f19818403018152919052805160209182012082546001810184556000938452919092200155505050565b8060035411156123bf5750565b6002805460035490916000916123d7906001906129af565b815481106123e7576123e7612999565b90600052602060002001549050600061240860016003546104dc91906129af565b6003549091505b838110156124d0576040805160208082018690528183018590528251808303840181526060909201909252805191012060015461245090600290841c6129c2565b6000036124995780935061246382610c92565b925085821061249457806002838154811061248057612480612999565b600091825260209091200155505050505050565b6124bd565b600282815481106124ac576124ac612999565b906000526020600020015493508092505b50806124c881612943565b91505061240f565b5050505050565b6000602082840312156124e957600080fd5b5035919050565b60006020828403121561250257600080fd5b81356001600160801b038116811461087a57600080fd5b6000806040838503121561252c57600080fd5b50508035926020909101359150565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff811182821017156125745761257461253b565b60405290565b6040516060810167ffffffffffffffff811182821017156125745761257461253b565b604051601f8201601f1916810167ffffffffffffffff811182821017156125c6576125c661253b565b604052919050565b600067ffffffffffffffff8211156125e8576125e861253b565b5060051b60200190565b600082601f83011261260357600080fd5b81356020612618612613836125ce565b61259d565b82815260069290921b8401810191818101908684111561263757600080fd5b8286015b8481101561267657604081890312156126545760008081fd5b61265c612551565b81358152848201358582015283529183019160400161263b565b509695505050505050565b60006060828403121561269357600080fd5b61269b61257a565b90508135815260208083013567ffffffffffffffff808211156126bd57600080fd5b818501915085601f8301126126d157600080fd5b8135818111156126e3576126e361253b565b6126f5601f8201601f1916850161259d565b818152878583860101111561270957600080fd5b8185850186830137600085838301015280858701525050604085013592508083111561273457600080fd5b5050612742848285016125f2565b60408301525092915050565b6000602080838503121561276157600080fd5b823567ffffffffffffffff8082111561277957600080fd5b818501915085601f83011261278d57600080fd5b813561279b612613826125ce565b81815260059190911b830184019084810190888311156127ba57600080fd5b8585015b838110156127f2578035858111156127d65760008081fd5b6127e48b89838a0101612681565b8452509186019186016127be565b5098975050505050505050565b600081518084526020808501945080840160005b8381101561282f57815187529582019590820190600101612813565b509495945050505050565b60808152600061284d60808301876127ff565b82810360208481019190915286518083528782019282019060005b8181101561288457845183529383019391830191600101612868565b5050848103604086015261289881886127ff565b9250505082810360608401526128ae81856127ff565b979650505050505050565b6000602082840312156128cb57600080fd5b813567ffffffffffffffff8111156128e257600080fd5b6128ee84828501612681565b949350505050565b6020808252601a908201527f436f6e747261637420686173206e6f74206c61756e636865642e000000000000604082015260600190565b634e487b7160e01b600052601160045260246000fd5b6000600182016129555761295561292d565b5060010190565b808201808211156108b5576108b561292d565b634e487b7160e01b600052601260045260246000fd5b6000826129945761299461296f565b500490565b634e487b7160e01b600052603260045260246000fd5b818103818111156108b5576108b561292d565b6000826129d1576129d161296f565b500690565b600081518084526020808501945080840160005b8381101561282f5781518051885283015183880152604090960195908201906001016129ea565b848152600060208581840152846040840152608060608401528351608084015280840151606060a085015280518060e086015260005b81811015612a645782810184015186820161010001528301612a47565b5061010092506000838287010152601f19601f8201168501915050604085015160808583030160c0860152612a9b838301826129d6565b9998505050505050505050565b600060208284031215612aba57600080fd5b5051919050565b634e487b7160e01b600052600160045260246000fd5b6000816000190483118215151615612af157612af161292d565b500290565b600060208284031215612b0857600080fd5b81516001600160a01b038116811461087a57600080fd5b60208152600061087a60208301846129d656fea2646970667358221220e377cee588fd799febc8e15969a547b0a21cc3e04618ae49bf1350bd131c5f7d64736f6c63430008100033608060405234801561001057600080fd5b5060405161067138038061067183398101604081905261002f9161014a565b6100383361009a565b806001600160401b0381111561005057610050610163565b604051908082528060200260200182016040528015610079578160200160208202803683370190505b50805161008e916001916020909101906100ea565b50506000600255610179565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b828054828255906000526020600020908101928215610125579160200282015b8281111561012557825182559160200191906001019061010a565b50610131929150610135565b5090565b5b808211156101315760008155600101610136565b60006020828403121561015c57600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b6104e9806101886000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c80638da5cb5b1161005b5780638da5cb5b146100d557806396e494e8146100f0578063e0886f9014610103578063f2fde38b1461011657600080fd5b80631d1a696d146100825780632d287e43146100aa578063715018a6146100cb575b600080fd5b6100956100903660046103e4565b610129565b60405190151581526020015b60405180910390f35b6100bd6100b83660046103e4565b610194565b6040519081526020016100a1565b6100d36101ee565b005b6000546040516001600160a01b0390911681526020016100a1565b6100956100fe3660046103e4565b610202565b6100bd6101113660046103e4565b610237565b6100d36101243660046103fd565b610297565b60008061013d600254600180549050610310565b905060005b8181101561018a57836001828154811061015e5761015e610426565b906000526020600020015403610178575060019392505050565b8061018281610452565b915050610142565b5060009392505050565b6002546001546000919082906101aa908361046b565b905083600182815481106101c0576101c0610426565b90600052602060002001819055506001600260008282546101e1919061048d565b9091555091949350505050565b6101f661032a565b6102006000610384565b565b6001546002546000919083108015610230575080610222600254836103d4565b61022c91906104a0565b8310155b9392505050565b600061024282610202565b6102675760405163b52d71f360e01b8152600481018390526024015b60405180910390fd5b60018054610275908461046b565b8154811061028557610285610426565b90600052602060002001549050919050565b61029f61032a565b6001600160a01b0381166103045760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b606482015260840161025e565b61030d81610384565b50565b600081831061031f5781610321565b825b90505b92915050565b6000546001600160a01b031633146102005760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161025e565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60008183101561031f5781610321565b6000602082840312156103f657600080fd5b5035919050565b60006020828403121561040f57600080fd5b81356001600160a01b038116811461023057600080fd5b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016104645761046461043c565b5060010190565b60008261048857634e487b7160e01b600052601260045260246000fd5b500690565b808201808211156103245761032461043c565b818103818111156103245761032461043c56fea26469706673582212202d7a75b8d01477d7b0dfd4de81e732d9f919a499a532643d0950277377b9966e64736f6c63430008100033";const isSuperArgs=xs=>xs.length>1;class Flow__factory extends ContractFactory{constructor(...args){if(isSuperArgs(args)){super(...args)}else{super(_abi,_bytecode,args[0])}}getDeployTransaction(book_,blocksPerEpoch_,deployDelay_,overrides){return super.getDeployTransaction(book_,blocksPerEpoch_,deployDelay_,overrides||{})}deploy(book_,blocksPerEpoch_,deployDelay_,overrides){return super.deploy(book_,blocksPerEpoch_,deployDelay_,overrides||{})}connect(runner){return super.connect(runner)}static bytecode=_bytecode;static abi=_abi;static createInterface(){return new Interface(_abi)}static connect(address,runner){return new Contract(address,_abi,runner)}}var index=Object.freeze({__proto__:null,Flow__factory:Flow__factory});function getFlowContract(address,signer){return Flow__factory.connect(address,signer)}function checkExist(inputPath){const dirName=path.dirname(inputPath);if(!fs.existsSync(dirName)){return true}if(fs.existsSync(inputPath)&&fs.lstatSync(inputPath).isDirectory()){return true}if(!fs.existsSync(inputPath)){return false}return true}function GetSplitNum(total,unit){return Math.floor((total-1)/unit+1)}class Downloader{node;constructor(node){this.node=node}async downloadFileHelper(root,filePath,size,proof){const segmentOffset=0;const numChunks=GetSplitNum(size,DEFAULT_CHUNK_SIZE);const numSegments=GetSplitNum(size,DEFAULT_SEGMENT_SIZE);const numTasks=numSegments-segmentOffset;for(let taskInd=0;taskInd<numTasks;taskInd++){const segmentIndex=segmentOffset+taskInd;const startIndex=segmentIndex*DEFAULT_SEGMENT_MAX_CHUNKS;var endIndex=startIndex+DEFAULT_SEGMENT_MAX_CHUNKS;if(endIndex>numChunks){endIndex=numChunks}var segment=await this.node.downloadSegment(root,startIndex,endIndex);var segArray=decodeBase64(segment);if(segment==null){return new Error("Failed to download segment")}if(segmentIndex==numSegments-1){const lastChunkSize=size%DEFAULT_CHUNK_SIZE;if(lastChunkSize>0){const paddings=DEFAULT_CHUNK_SIZE-lastChunkSize;segArray=segArray.slice(0,segArray.length-paddings)}}fs.appendFileSync(filePath,segArray)}return null}async downloadFile(root,filePath,proof){const info=await this.node.getFileInfo(root);if(info==null){return new Error("File not found")}if(!info.finalized){return new Error("File not finalized")}if(checkExist(filePath)){return new Error("Wrong path, provide a file path which does not exist.")}let err=await this.downloadFileHelper(root,filePath,info.tx.size,proof);return err}}class Uploader{node;constructor(node){this.node=node}async uploadFile(file,segIndex=0){const[tree,err]=await file.merkleTree();if(tree==null||err!=null){return err}const iter=file.iterateWithOffsetAndBatch(segIndex*DEFAULT_SEGMENT_SIZE,DEFAULT_SEGMENT_SIZE,true);const numChunks=file.numChunks();const fileSize=file.size();while(true){let[ok,err]=await iter.next();if(err){return new Error("Failed to read segment")}if(!ok){break}let segment=iter.current();const proof=tree.proofAt(segIndex);const startIndex=segIndex*DEFAULT_SEGMENT_MAX_CHUNKS;let allDataUploaded=false;if(startIndex>=numChunks){break}else if(startIndex+segment.length/DEFAULT_CHUNK_SIZE>=numChunks){const expectedLen=DEFAULT_CHUNK_SIZE*(numChunks-startIndex);segment=segment.slice(0,expectedLen);allDataUploaded=true}const segWithProof={root:tree.rootHash(),data:encodeBase64(segment),index:segIndex,proof:proof,fileSize:fileSize};try{await this.node.uploadSegment(segWithProof)}catch(e){return e}if(allDataUploaded){break}segIndex++}return null}}class JsonRpcError extends Error{constructor(message,code,data){super(message);this.code=code;this.data=data}}class BaseProvider{constructor(options){this.url=options.url;this.timeout=options.timeout||3e4;this.retry=options.retry||3}_transport(data){throw new Error("_transport not implemented")}_transportBatch(data){throw new Error("_transportBatch not implemented")}id(){const id=(Date.now()+Math.random())*1e4;return Number(id)}buildRpcPayload(req){return{jsonrpc:"2.0",method:req.method,params:req.params,id:this.id()}}async request(req){const data=await this._transport(this.buildRpcPayload(req));const{result,error}=data;if(error)throw new JsonRpcError(error.message,error.code,error.data);return result}async requestBatch(batch){const data=await this._transportBatch(batch.map(this.buildRpcPayload));return data.map(({result,error})=>{return error?new JsonRpcError(error.message,error.code,error.data):result})}send(method,params){return this.request({method:method,params:params})}sendAsync(payload,callback){this._transport(payload).then(data=>callback(null,data)).catch(err=>callback(err))}call(method,...args){return this.request({method:method,params:args})}close(){}}var axios$3={exports:{}};var bind$2=function bind(fn,thisArg){return function wrap(){var args=new Array(arguments.length);for(var i=0;i<args.length;i++){args[i]=arguments[i]}return fn.apply(thisArg,args)}};var bind$1=bind$2;var toString=Object.prototype.toString;var kindOf=function(cache){return function(thing){var str=toString.call(thing);return cache[str]||(cache[str]=str.slice(8,-1).toLowerCase())}}(Object.create(null));function kindOfTest(type){type=type.toLowerCase();return function isKindOf(thing){return kindOf(thing)===type}}function isArray(val){return Array.isArray(val)}function isUndefined(val){return typeof val==="undefined"}function isBuffer(val){return val!==null&&!isUndefined(val)&&val.constructor!==null&&!isUndefined(val.constructor)&&typeof val.constructor.isBuffer==="function"&&val.constructor.isBuffer(val)}var isArrayBuffer=kindOfTest("ArrayBuffer");function isArrayBufferView(val){var result;if(typeof ArrayBuffer!=="undefined"&&ArrayBuffer.isView){result=ArrayBuffer.isView(val)}else{result=val&&val.buffer&&isArrayBuffer(val.buffer)}return result}function isString(val){return typeof val==="string"}function isNumber(val){return typeof val==="number"}function isObject(val){return val!==null&&typeof val==="object"}function isPlainObject(val){if(kindOf(val)!=="object"){return false}var prototype=Object.getPrototypeOf(val);return prototype===null||prototype===Object.prototype}var isDate=kindOfTest("Date");var isFile=kindOfTest("File");var isBlob=kindOfTest("Blob");var isFileList=kindOfTest("FileList");function isFunction(val){return toString.call(val)==="[object Function]"}function isStream(val){return isObject(val)&&isFunction(val.pipe)}function isFormData(thing){var pattern="[object FormData]";return thing&&(typeof FormData==="function"&&thing instanceof FormData||toString.call(thing)===pattern||isFunction(thing.toString)&&thing.toString()===pattern)}var isURLSearchParams=kindOfTest("URLSearchParams");function trim(str){return str.trim?str.trim():str.replace(/^\s+|\s+$/g,"")}function isStandardBrowserEnv(){if(typeof navigator!=="undefined"&&(navigator.product==="ReactNative"||navigator.product==="NativeScript"||navigator.product==="NS")){return false}return typeof window!=="undefined"&&typeof document!=="undefined"}function forEach(obj,fn){if(obj===null||typeof obj==="undefined"){return}if(typeof obj!=="object"){obj=[obj]}if(isArray(obj)){for(var i=0,l=obj.length;i<l;i++){fn.call(null,obj[i],i,obj)}}else{for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){fn.call(null,obj[key],key,obj)}}}}function merge(){var result={};function assignValue(val,key){if(isPlainObject(result[key])&&isPlainObject(val)){result[key]=merge(result[key],val)}else if(isPlainObject(val)){result[key]=merge({},val)}else if(isArray(val)){result[key]=val.slice()}else{result[key]=val}}for(var i=0,l=arguments.length;i<l;i++){forEach(arguments[i],assignValue)}return result}function extend(a,b,thisArg){forEach(b,function assignValue(val,key){if(thisArg&&typeof val==="function"){a[key]=bind$1(val,thisArg)}else{a[key]=val}});return a}function stripBOM(content){if(content.charCodeAt(0)===65279){content=content.slice(1)}return content}function inherits(constructor,superConstructor,props,descriptors){constructor.prototype=Object.create(superConstructor.prototype,descriptors);constructor.prototype.constructor=constructor;props&&Object.assign(constructor.prototype,props)}function toFlatObject(sourceObj,destObj,filter){var props;var i;var prop;var merged={};destObj=destObj||{};do{props=Object.getOwnPropertyNames(sourceObj);i=props.length;while(i-- >0){prop=props[i];if(!merged[prop]){destObj[prop]=sourceObj[prop];merged[prop]=true}}sourceObj=Object.getPrototypeOf(sourceObj)}while(sourceObj&&(!filter||filter(sourceObj,destObj))&&sourceObj!==Object.prototype);return destObj}function endsWith(str,searchString,position){str=String(str);if(position===undefined||position>str.length){position=str.length}position-=searchString.length;var lastIndex=str.indexOf(searchString,position);return lastIndex!==-1&&lastIndex===position}function toArray(thing){if(!thing)return null;var i=thing.length;if(isUndefined(i))return null;var arr=new Array(i);while(i-- >0){arr[i]=thing[i]}return arr}var isTypedArray=function(TypedArray){return function(thing){return TypedArray&&thing instanceof TypedArray}}(typeof Uint8Array!=="undefined"&&Object.getPrototypeOf(Uint8Array));var utils$9={isArray:isArray,isArrayBuffer:isArrayBuffer,isBuffer:isBuffer,isFormData:isFormData,isArrayBufferView:isArrayBufferView,isString:isString,isNumber:isNumber,isObject:isObject,isPlainObject:isPlainObject,isUndefined:isUndefined,isDate:isDate,isFile:isFile,isBlob:isBlob,isFunction:isFunction,isStream:isStream,isURLSearchParams:isURLSearchParams,isStandardBrowserEnv:isStandardBrowserEnv,forEach:forEach,merge:merge,extend:extend,trim:trim,stripBOM:stripBOM,inherits:inherits,toFlatObject:toFlatObject,kindOf:kindOf,kindOfTest:kindOfTest,endsWith:endsWith,toArray:toArray,isTypedArray:isTypedArray,isFileList:isFileList};var utils$8=utils$9;function encode(val){return encodeURIComponent(val).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}var buildURL$1=function buildURL(url,params,paramsSerializer){if(!params){return url}var serializedParams;if(paramsSerializer){serializedParams=paramsSerializer(params)}else if(utils$8.isURLSearchParams(params)){serializedParams=params.toString()}else{var parts=[];utils$8.forEach(params,function serialize(val,key){if(val===null||typeof val==="undefined"){return}if(utils$8.isArray(val)){key=key+"[]"}else{val=[val]}utils$8.forEach(val,function parseValue(v){if(utils$8.isDate(v)){v=v.toISOString()}else if(utils$8.isObject(v)){v=JSON.stringify(v)}parts.push(encode(key)+"="+encode(v))})});serializedParams=parts.join("&")}if(serializedParams){var hashmarkIndex=url.indexOf("#");if(hashmarkIndex!==-1){url=url.slice(0,hashmarkIndex)}url+=(url.indexOf("?")===-1?"?":"&")+serializedParams}return url};var utils$7=utils$9;function InterceptorManager$1(){this.handlers=[]}InterceptorManager$1.prototype.use=function use(fulfilled,rejected,options){this.handlers.push({fulfilled:fulfilled,rejected:rejected,synchronous:options?options.synchronous:false,runWhen:options?options.runWhen:null});return this.handlers.length-1};InterceptorManager$1.prototype.eject=function eject(id){if(this.handlers[id]){this.handlers[id]=null}};InterceptorManager$1.prototype.forEach=function forEach(fn){utils$7.forEach(this.handlers,function forEachHandler(h){if(h!==null){fn(h)}})};var InterceptorManager_1=InterceptorManager$1;var utils$6=utils$9;var normalizeHeaderName$1=function normalizeHeaderName(headers,normalizedName){utils$6.forEach(headers,function processHeader(value,name){if(name!==normalizedName&&name.toUpperCase()===normalizedName.toUpperCase()){headers[normalizedName]=value;delete headers[name]}})};var AxiosError_1;var hasRequiredAxiosError;function requireAxiosError(){if(hasRequiredAxiosError)return AxiosError_1;hasRequiredAxiosError=1;var utils=utils$9;function AxiosError(message,code,config,request,response){Error.call(this);this.message=message;this.name="AxiosError";code&&(this.code=code);config&&(this.config=config);request&&(this.request=request);response&&(this.response=response)}utils.inherits(AxiosError,Error,{toJSON:function toJSON(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}}});var prototype=AxiosError.prototype;var descriptors={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED"].forEach(function(code){descriptors[code]={value:code}});Object.defineProperties(AxiosError,descriptors);Object.defineProperty(prototype,"isAxiosError",{value:true});AxiosError.from=function(error,code,config,request,response,customProps){var axiosError=Object.create(prototype);utils.toFlatObject(error,axiosError,function filter(obj){return obj!==Error.prototype});AxiosError.call(axiosError,error.message,code,config,request,response);axiosError.name=error.name;customProps&&Object.assign(axiosError,customProps);return axiosError};AxiosError_1=AxiosError;return AxiosError_1}var transitional={silentJSONParsing:true,forcedJSONParsing:true,clarifyTimeoutError:false};var toFormData_1;var hasRequiredToFormData;function requireToFormData(){if(hasRequiredToFormData)return toFormData_1;hasRequiredToFormData=1;var utils=utils$9;function toFormData(obj,formData){formData=formData||new FormData;var stack=[];function convertValue(value){if(value===null)return"";if(utils.isDate(value)){return value.toISOString()}if(utils.isArrayBuffer(value)||utils.isTypedArray(value)){return typeof Blob==="function"?new Blob([value]):Buffer.from(value)}return value}function build(data,parentKey){if(utils.isPlainObject(data)||utils.isArray(data)){if(stack.indexOf(data)!==-1){throw Error("Circular reference detected in "+parentKey)}stack.push(data);utils.forEach(data,function each(value,key){if(utils.isUndefined(value))return;var fullKey=parentKey?parentKey+"."+key:key;var arr;if(value&&!parentKey&&typeof value==="object"){if(utils.endsWith(key,"{}")){value=JSON.stringify(value)}else if(utils.endsWith(key,"[]")&&(arr=utils.toArray(value))){arr.forEach(function(el){!utils.isUndefined(el)&&formData.append(fullKey,convertValue(el))});return}}build(value,fullKey)});stack.pop()}else{formData.append(parentKey,convertValue(data))}}build(obj);return formData}toFormData_1=toFormData;return toFormData_1}var settle;var hasRequiredSettle;function requireSettle(){if(hasRequiredSettle)return settle;hasRequiredSettle=1;var AxiosError=requireAxiosError();settle=function settle(resolve,reject,response){var validateStatus=response.config.validateStatus;if(!response.status||!validateStatus||validateStatus(response.status)){resolve(response)}else{reject(new AxiosError("Request failed with status code "+response.status,[AxiosError.ERR_BAD_REQUEST,AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status/100)-4],response.config,response.request,response))}};return settle}var cookies;var hasRequiredCookies;function requireCookies(){if(hasRequiredCookies)return cookies;hasRequiredCookies=1;var utils=utils$9;cookies=utils.isStandardBrowserEnv()?function standardBrowserEnv(){return{write:function write(name,value,expires,path,domain,secure){var cookie=[];cookie.push(name+"="+encodeURIComponent(value));if(utils.isNumber(expires)){cookie.push("expires="+new Date(expires).toGMTString())}if(utils.isString(path)){cookie.push("path="+path)}if(utils.isString(domain)){cookie.push("domain="+domain)}if(secure===true){cookie.push("secure")}document.cookie=cookie.join("; ")},read:function read(name){var match=document.cookie.match(new RegExp("(^|;\\s*)("+name+")=([^;]*)"));return match?decodeURIComponent(match[3]):null},remove:function remove(name){this.write(name,"",Date.now()-864e5)}}}():function nonStandardBrowserEnv(){return{write:function write(){},read:function read(){return null},remove:function remove(){}}}();return cookies}var isAbsoluteURL$1=function isAbsoluteURL(url){return/^([a-z][a-z\d+\-.]*:)?\/\//i.test(url)};var combineURLs$1=function combineURLs(baseURL,relativeURL){return relativeURL?baseURL.replace(/\/+$/,"")+"/"+relativeURL.replace(/^\/+/,""):baseURL};var isAbsoluteURL=isAbsoluteURL$1;var combineURLs=combineURLs$1;var buildFullPath$1=function buildFullPath(baseURL,requestedURL){if(baseURL&&!isAbsoluteURL(requestedURL)){return combineURLs(baseURL,requestedURL)}return requestedURL};var parseHeaders;var hasRequiredParseHeaders;function requireParseHeaders(){if(hasRequiredParseHeaders)return parseHeaders;hasRequiredParseHeaders=1;var utils=utils$9;var ignoreDuplicateOf=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];parseHeaders=function parseHeaders(headers){var parsed={};var key;var val;var i;if(!headers){return parsed}utils.forEach(headers.split("\n"),function parser(line){i=line.indexOf(":");key=utils.trim(line.substr(0,i)).toLowerCase();val=utils.trim(line.substr(i+1));if(key){if(parsed[key]&&ignoreDuplicateOf.indexOf(key)>=0){return}if(key==="set-cookie"){parsed[key]=(parsed[key]?parsed[key]:[]).concat([val])}else{parsed[key]=parsed[key]?parsed[key]+", "+val:val}}});return parsed};return parseHeaders}var isURLSameOrigin;var hasRequiredIsURLSameOrigin;function requireIsURLSameOrigin(){if(hasRequiredIsURLSameOrigin)return isURLSameOrigin;hasRequiredIsURLSameOrigin=1;var utils=utils$9;isURLSameOrigin=utils.isStandardBrowserEnv()?function standardBrowserEnv(){var msie=/(msie|trident)/i.test(navigator.userAgent);var urlParsingNode=document.createElement("a");var originURL;function resolveURL(url){var href=url;if(msie){urlParsingNode.setAttribute("href",href);href=urlParsingNode.href}urlParsingNode.setAttribute("href",href);return{href:urlParsingNode.href,protocol:urlParsingNode.protocol?urlParsingNode.protocol.replace(/:$/,""):"",host:urlParsingNode.host,search:urlParsingNode.search?urlParsingNode.search.replace(/^\?/,""):"",hash:urlParsingNode.hash?urlParsingNode.hash.replace(/^#/,""):"",hostname:urlParsingNode.hostname,port:urlParsingNode.port,pathname:urlParsingNode.pathname.charAt(0)==="/"?urlParsingNode.pathname:"/"+urlParsingNode.pathname}}originURL=resolveURL(window.location.href);return function isURLSameOrigin(requestURL){var parsed=utils.isString(requestURL)?resolveURL(requestURL):requestURL;return parsed.protocol===originURL.protocol&&parsed.host===originURL.host}}():function nonStandardBrowserEnv(){return function isURLSameOrigin(){return true}}();return isURLSameOrigin}var CanceledError_1;var hasRequiredCanceledError;function requireCanceledError(){if(hasRequiredCanceledError)return CanceledError_1;hasRequiredCanceledError=1;var AxiosError=requireAxiosError();var utils=utils$9;function CanceledError(message){AxiosError.call(this,message==null?"canceled":message,AxiosError.ERR_CANCELED);this.name="CanceledError"}utils.inherits(CanceledError,AxiosError,{__CANCEL__:true});CanceledError_1=CanceledError;return CanceledError_1}var parseProtocol;var hasRequiredParseProtocol;function requireParseProtocol(){if(hasRequiredParseProtocol)return parseProtocol;hasRequiredParseProtocol=1;parseProtocol=function parseProtocol(url){var match=/^([-+\w]{1,25})(:?\/\/|:)/.exec(url);return match&&match[1]||""};return parseProtocol}var xhr;var hasRequiredXhr;function requireXhr(){if(hasRequiredXhr)return xhr;hasRequiredXhr=1;var utils=utils$9;var settle=requireSettle();var cookies=requireCookies();var buildURL=buildURL$1;var buildFullPath=buildFullPath$1;var parseHeaders=requireParseHeaders();var isURLSameOrigin=requireIsURLSameOrigin();var transitionalDefaults=transitional;var AxiosError=requireAxiosError();var CanceledError=requireCanceledError();var parseProtocol=requireParseProtocol();xhr=function xhrAdapter(config){return new Promise(function dispatchXhrRequest(resolve,reject){var requestData=config.data;var requestHeaders=config.headers;var responseType=config.responseType;var onCanceled;function done(){if(config.cancelToken){config.cancelToken.unsubscribe(onCanceled)}if(config.signal){config.signal.removeEventListener("abort",onCanceled)}}if(utils.isFormData(requestData)&&utils.isStandardBrowserEnv()){delete requestHeaders["Content-Type"]}var request=new XMLHttpRequest;if(config.auth){var username=config.auth.username||"";var password=config.auth.password?unescape(encodeURIComponent(config.auth.password)):"";requestHeaders.Authorization="Basic "+btoa(username+":"+password)}var fullPath=buildFullPath(config.baseURL,config.url);request.open(config.method.toUpperCase(),buildURL(fullPath,config.params,config.paramsSerializer),true);request.timeout=config.timeout;function onloadend(){if(!request){return}var responseHeaders="getAllResponseHeaders"in request?parseHeaders(request.getAllResponseHeaders()):null;var responseData=!responseType||responseType==="text"||responseType==="json"?request.responseText:request.response;var response={data:responseData,status:request.status,statusText:request.statusText,headers:responseHeaders,config:config,request:request};settle(function _resolve(value){resolve(value);done()},function _reject(err){reject(err);done()},response);request=null}if("onloadend"in request){request.onloadend=onloadend}else{request.onreadystatechange=function handleLoad(){if(!request||request.readyState!==4){return}if(request.status===0&&!(request.responseURL&&request.responseURL.indexOf("file:")===0)){return}setTimeout(onloadend)}}request.onabort=function handleAbort(){if(!request){return}reject(new AxiosError("Request aborted",AxiosError.ECONNABORTED,config,request));request=null};request.onerror=function handleError(){reject(new AxiosError("Network Error",AxiosError.ERR_NETWORK,config,request,request));request=null};request.ontimeout=function handleTimeout(){var timeoutErrorMessage=config.timeout?"timeout of "+config.timeout+"ms exceeded":"timeout exceeded";var transitional=config.transitional||transitionalDefaults;if(config.timeoutErrorMessage){timeoutErrorMessage=config.timeoutErrorMessage}reject(new AxiosError(timeoutErrorMessage,transitional.clarifyTimeoutError?AxiosError.ETIMEDOUT:AxiosError.ECONNABORTED,config,request));request=null};if(utils.isStandardBrowserEnv()){var xsrfValue=(config.withCredentials||isURLSameOrigin(fullPath))&&config.xsrfCookieName?cookies.read(config.xsrfCookieName):undefined;if(xsrfValue){requestHeaders[config.xsrfHeaderName]=xsrfValue}}if("setRequestHeader"in request){utils.forEach(requestHeaders,function setRequestHeader(val,key){if(typeof requestData==="undefined"&&key.toLowerCase()==="content-type"){delete requestHeaders[key]}else{request.setRequestHeader(key,val)}})}if(!utils.isUndefined(config.withCredentials)){request.withCredentials=!!config.withCredentials}if(responseType&&responseType!=="json"){request.responseType=config.responseType}if(typeof config.onDownloadProgress==="function"){request.addEventListener("progress",config.onDownloadProgress)}if(typeof config.onUploadProgress==="function"&&request.upload){request.upload.addEventListener("progress",config.onUploadProgress)}if(config.cancelToken||config.signal){onCanceled=function(cancel){if(!request){return}reject(!cancel||cancel&&cancel.type?new CanceledError:cancel);request.abort();request=null};config.cancelToken&&config.cancelToken.subscribe(onCanceled);if(config.signal){config.signal.aborted?onCanceled():config.signal.addEventListener("abort",onCanceled)}}if(!requestData){requestData=null}var protocol=parseProtocol(fullPath);if(protocol&&["http","https","file"].indexOf(protocol)===-1){reject(new AxiosError("Unsupported protocol "+protocol+":",AxiosError.ERR_BAD_REQUEST,config));return}request.send(requestData)})};return xhr}var _null;var hasRequired_null;function require_null(){if(hasRequired_null)return _null;hasRequired_null=1;_null=null;return _null}var utils$5=utils$9;var normalizeHeaderName=normalizeHeaderName$1;var AxiosError$1=requireAxiosError();var transitionalDefaults=transitional;var toFormData=requireToFormData();var DEFAULT_CONTENT_TYPE={"Content-Type":"application/x-www-form-urlencoded"};function setContentTypeIfUnset(headers,value){if(!utils$5.isUndefined(headers)&&utils$5.isUndefined(headers["Content-Type"])){headers["Content-Type"]=value}}function getDefaultAdapter(){var adapter;if(typeof XMLHttpRequest!=="undefined"){adapter=requireXhr()}else if(typeof process!=="undefined"&&Object.prototype.toString.call(process)==="[object process]"){adapter=requireXhr()}return adapter}function stringifySafely(rawValue,parser,encoder){if(utils$5.isString(rawValue)){try{(parser||JSON.parse)(rawValue);return utils$5.trim(rawValue)}catch(e){if(e.name!=="SyntaxError"){throw e}}}return(encoder||JSON.stringify)(rawValue)}var defaults$3={transitional:transitionalDefaults,adapter:getDefaultAdapter(),transformRequest:[function transformRequest(data,headers){normalizeHeaderName(headers,"Accept");normalizeHeaderName(headers,"Content-Type");if(utils$5.isFormData(data)||utils$5.isArrayBuffer(data)||utils$5.isBuffer(data)||utils$5.isStream(data)||utils$5.isFile(data)||utils$5.isBlob(data)){return data}if(utils$5.isArrayBufferView(data)){return data.buffer}if(utils$5.isURLSearchParams(data)){setContentTypeIfUnset(headers,"application/x-www-form-urlencoded;charset=utf-8");return data.toString()}var isObjectPayload=utils$5.isObject(data);var contentType=headers&&headers["Content-Type"];var isFileList;if((isFileList=utils$5.isFileList(data))||isObjectPayload&&contentType==="multipart/form-data"){var _FormData=this.env&&this.env.FormData;return toFormData(isFileList?{"files[]":data}:data,_FormData&&new _FormData)}else if(isObjectPayload||contentType==="application/json"){setContentTypeIfUnset(headers,"application/json");return stringifySafely(data)}return data}],transformResponse:[function transformResponse(data){var transitional=this.transitional||defaults$3.transitional;var silentJSONParsing=transitional&&transitional.silentJSONParsing;var forcedJSONParsing=transitional&&transitional.forcedJSONParsing;var strictJSONParsing=!silentJSONParsing&&this.responseType==="json";if(strictJSONParsing||forcedJSONParsing&&utils$5.isString(data)&&data.length){try{return JSON.parse(data)}catch(e){if(strictJSONParsing){if(e.name==="SyntaxError"){throw AxiosError$1.from(e,AxiosError$1.ERR_BAD_RESPONSE,this,null,this.response)}throw e}}}return data}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:require_null()},validateStatus:function validateStatus(status){return status>=200&&status<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};utils$5.forEach(["delete","get","head"],function forEachMethodNoData(method){defaults$3.headers[method]={}});utils$5.forEach(["post","put","patch"],function forEachMethodWithData(method){defaults$3.headers[method]=utils$5.merge(DEFAULT_CONTENT_TYPE)});var defaults_1=defaults$3;var utils$4=utils$9;var defaults$2=defaults_1;var transformData$1=function transformData(data,headers,fns){var context=this||defaults$2;utils$4.forEach(fns,function transform(fn){data=fn.call(context,data,headers)});return data};var isCancel$1;var hasRequiredIsCancel;function requireIsCancel(){if(hasRequiredIsCancel)return isCancel$1;hasRequiredIsCancel=1;isCancel$1=function isCancel(value){return!!(value&&value.__CANCEL__)};return isCancel$1}var utils$3=utils$9;var transformData=transformData$1;var isCancel=requireIsCancel();var defaults$1=defaults_1;var CanceledError=requireCanceledError();function throwIfCancellationRequested(config){if(config.cancelToken){config.cancelToken.throwIfRequested()}if(config.signal&&config.signal.aborted){throw new CanceledError}}var dispatchRequest$1=function dispatchRequest(config){throwIfCancellationRequested(config);config.headers=config.headers||{};config.data=transformData.call(config,config.data,config.headers,config.transformRequest);config.headers=utils$3.merge(config.headers.common||{},config.headers[config.method]||{},config.headers);utils$3.forEach(["delete","get","head","post","put","patch","common"],function cleanHeaderConfig(method){delete config.headers[method]});var adapter=config.adapter||defaults$1.adapter;return adapter(config).then(function onAdapterResolution(response){throwIfCancellationRequested(config);response.data=transformData.call(config,response.data,response.headers,config.transformResponse);return response},function onAdapterRejection(reason){if(!isCancel(reason)){throwIfCancellationRequested(config);if(reason&&reason.response){reason.response.data=transformData.call(config,reason.response.data,reason.response.headers,config.transformResponse)}}return Promise.reject(reason)})};var utils$2=utils$9;var mergeConfig$2=function mergeConfig(config1,config2){config2=config2||{};var config={};function getMergedValue(target,source){if(utils$2.isPlainObject(target)&&utils$2.isPlainObject(source)){return utils$2.merge(target,source)}else if(utils$2.isPlainObject(source)){return utils$2.merge({},source)}else if(utils$2.isArray(source)){return source.slice()}return source}function mergeDeepProperties(prop){if(!utils$2.isUndefined(config2[prop])){return getMergedValue(config1[prop],config2[prop])}else if(!utils$2.isUndefined(config1[prop])){return getMergedValue(undefined,config1[prop])}}function valueFromConfig2(prop){if(!utils$2.isUndefined(config2[prop])){return getMergedValue(undefined,config2[prop])}}function defaultToConfig2(prop){if(!utils$2.isUndefined(config2[prop])){return getMergedValue(undefined,config2[prop])}else if(!utils$2.isUndefined(config1[prop])){return getMergedValue(undefined,config1[prop])}}function mergeDirectKeys(prop){if(prop in config2){return getMergedValue(config1[prop],config2[prop])}else if(prop in config1){return getMergedValue(undefined,config1[prop])}}var mergeMap={url:valueFromConfig2,method:valueFromConfig2,data:valueFromConfig2,baseURL:defaultToConfig2,transformRequest:defaultToConfig2,transformResponse:defaultToConfig2,paramsSerializer:defaultToConfig2,timeout:defaultToConfig2,timeoutMessage:defaultToConfig2,withCredentials:defaultToConfig2,adapter:defaultToConfig2,responseType:defaultToConfig2,xsrfCookieName:defaultToConfig2,xsrfHeaderName:defaultToConfig2,onUploadProgress:defaultToConfig2,onDownloadProgress:defaultToConfig2,decompress:defaultToConfig2,maxContentLength:defaultToConfig2,maxBodyLength:defaultToConfig2,beforeRedirect:defaultToConfig2,transport:defaultToConfig2,httpAgent:defaultToConfig2,httpsAgent:defaultToConfig2,cancelToken:defaultToConfig2,socketPath:defaultToConfig2,responseEncoding:defaultToConfig2,validateStatus:mergeDirectKeys};utils$2.forEach(Object.keys(config1).concat(Object.keys(config2)),function computeConfigValue(prop){var merge=mergeMap[prop]||mergeDeepProperties;var configValue=merge(prop);utils$2.isUndefined(configValue)&&merge!==mergeDirectKeys||(config[prop]=configValue)});return config};var data;var hasRequiredData;function requireData(){if(hasRequiredData)return data;hasRequiredData=1;data={version:"0.27.2"};return data}var VERSION=requireData().version;var AxiosError=requireAxiosError();var validators$1={};["object","boolean","number","function","string","symbol"].forEach(function(type,i){validators$1[type]=function validator(thing){return typeof thing===type||"a"+(i<1?"n ":" ")+type}});var deprecatedWarnings={};validators$1.transitional=function transitional(validator,version,message){function formatMessage(opt,desc){return"[Axios v"+VERSION+"] Transitional option '"+opt+"'"+desc+(message?". "+message:"")}return function(value,opt,opts){if(validator===false){throw new AxiosError(formatMessage(opt," has been removed"+(version?" in "+version:"")),AxiosError.ERR_DEPRECATED)}if(version&&!deprecatedWarnings[opt]){deprecatedWarnings[opt]=true;console.warn(formatMessage(opt," has been deprecated since v"+version+" and will be removed in the near future"))}return validator?validator(value,opt,opts):true}};function assertOptions(options,schema,allowUnknown){if(typeof options!=="object"){throw new AxiosError("options must be an object",AxiosError.ERR_BAD_OPTION_VALUE)}var keys=Object.keys(options);var i=keys.length;while(i-- >0){var opt=keys[i];var validator=schema[opt];if(validator){var value=options[opt];var result=value===undefined||validator(value,opt,options);if(result!==true){throw new AxiosError("option "+opt+" must be "+result,AxiosError.ERR_BAD_OPTION_VALUE)}continue}if(allowUnknown!==true){throw new AxiosError("Unknown option "+opt,AxiosError.ERR_BAD_OPTION)}}}var validator$1={assertOptions:assertOptions,validators:validators$1};var utils$1=utils$9;var buildURL=buildURL$1;var InterceptorManager=InterceptorManager_1;var dispatchRequest=dispatchRequest$1;var mergeConfig$1=mergeConfig$2;var buildFullPath=buildFullPath$1;var validator=validator$1;var validators=validator.validators;function Axios$1(instanceConfig){this.defaults=instanceConfig;this.interceptors={request:new InterceptorManager,response:new InterceptorManager}}Axios$1.prototype.request=function request(configOrUrl,config){if(typeof configOrUrl==="string"){config=config||{};config.url=configOrUrl}else{config=configOrUrl||{}}config=mergeConfig$1(this.defaults,config);if(config.method){config.method=config.method.toLowerCase()}else if(this.defaults.method){config.method=this.defaults.method.toLowerCase()}else{config.method="get"}var transitional=config.transitional;if(transitional!==undefined){validator.assertOptions(transitional,{silentJSONParsing:validators.transitional(validators.boolean),forcedJSONParsing:validators.transitional(validators.boolean),clarifyTimeoutError:validators.transitional(validators.boolean)},false)}var requestInterceptorChain=[];var synchronousRequestInterceptors=true;this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor){if(typeof interceptor.runWhen==="function"&&interceptor.runWhen(config)===false){return}synchronousRequestInterceptors=synchronousRequestInterceptors&&interceptor.synchronous;requestInterceptorChain.unshift(interceptor.fulfilled,interceptor.rejected)});var responseInterceptorChain=[];this.interceptors.response.forEach(function pushResponseInterceptors(interceptor){responseInterceptorChain.push(interceptor.fulfilled,interceptor.rejected)});var promise;if(!synchronousRequestInterceptors){var chain=[dispatchRequest,undefined];Array.prototype.unshift.apply(chain,requestInterceptorChain);chain=chain.concat(responseInterceptorChain);promise=Promise.resolve(config);while(chain.length){promise=promise.then(chain.shift(),chain.shift())}return promise}var newConfig=config;while(requestInterceptorChain.length){var onFulfilled=requestInterceptorChain.shift();var onRejected=requestInterceptorChain.shift();try{newConfig=onFulfilled(newConfig)}catch(error){onRejected(error);break}}try{promise=dispatchRequest(newConfig)}catch(error){return Promise.reject(error)}while(responseInterceptorChain.length){promise=promise.then(responseInterceptorChain.shift(),responseInterceptorChain.shift())}return promise};Axios$1.prototype.getUri=function getUri(config){config=mergeConfig$1(this.defaults,config);var fullPath=buildFullPath(config.baseURL,config.url);return buildURL(fullPath,config.params,config.paramsSerializer)};utils$1.forEach(["delete","get","head","options"],function forEachMethodNoData(method){Axios$1.prototype[method]=function(url,config){return this.request(mergeConfig$1(config||{},{method:method,url:url,data:(config||{}).data}))}});utils$1.forEach(["post","put","patch"],function forEachMethodWithData(method){function generateHTTPMethod(isForm){return function httpMethod(url,data,config){return this.request(mergeConfig$1(config||{},{method:method,headers:isForm?{"Content-Type":"multipart/form-data"}:{},url:url,data:data}))}}Axios$1.prototype[method]=generateHTTPMethod();Axios$1.prototype[method+"Form"]=generateHTTPMethod(true)});var Axios_1=Axios$1;var CancelToken_1;var hasRequiredCancelToken;function requireCancelToken(){if(hasRequiredCancelToken)return CancelToken_1;hasRequiredCancelToken=1;var CanceledError=requireCanceledError();function CancelToken(executor){if(typeof executor!=="function"){throw new TypeError("executor must be a function.")}var resolvePromise;this.promise=new Promise(function promiseExecutor(resolve){resolvePromise=resolve});var token=this;this.promise.then(function(cancel){if(!token._listeners)return;var i;var l=token._listeners.length;for(i=0;i<l;i++){token._listeners[i](cancel)}token._listeners=null});this.promise.then=function(onfulfilled){var _resolve;var promise=new Promise(function(resolve){token.subscribe(resolve);_resolve=resolve}).then(onfulfilled);promise.cancel=function reject(){token.unsubscribe(_resolve)};return promise};executor(function cancel(message){if(token.reason){return}token.reason=new CanceledError(message);resolvePromise(token.reason)})}CancelToken.prototype.throwIfRequested=function throwIfRequested(){if(this.reason){throw this.reason}};CancelToken.prototype.subscribe=function subscribe(listener){if(this.reason){listener(this.reason);return}if(this._listeners){this._listeners.push(listener)}else{this._listeners=[listener]}};CancelToken.prototype.unsubscribe=function unsubscribe(listener){if(!this._listeners){return}var index=this._listeners.indexOf(listener);if(index!==-1){this._listeners.splice(index,1)}};CancelToken.source=function source(){var cancel;var token=new CancelToken(function executor(c){cancel=c});return{token:token,cancel:cancel}};CancelToken_1=CancelToken;return CancelToken_1}var spread;var hasRequiredSpread;function requireSpread(){if(hasRequiredSpread)return spread;hasRequiredSpread=1;spread=function spread(callback){return function wrap(arr){return callback.apply(null,arr)}};return spread}var isAxiosError;var hasRequiredIsAxiosError;function requireIsAxiosError(){if(hasRequiredIsAxiosError)return isAxiosError;hasRequiredIsAxiosError=1;var utils=utils$9;isAxiosError=function isAxiosError(payload){return utils.isObject(payload)&&payload.isAxiosError===true};return isAxiosError}var utils=utils$9;var bind=bind$2;var Axios=Axios_1;var mergeConfig=mergeConfig$2;var defaults=defaults_1;function createInstance(defaultConfig){var context=new Axios(defaultConfig);var instance=bind(Axios.prototype.request,context);utils.extend(instance,Axios.prototype,context);utils.extend(instance,context);instance.create=function create(instanceConfig){return createInstance(mergeConfig(defaultConfig,instanceConfig))};return instance}var axios$2=createInstance(defaults);axios$2.Axios=Axios;axios$2.CanceledError=requireCanceledError();axios$2.CancelToken=requireCancelToken();axios$2.isCancel=requireIsCancel();axios$2.VERSION=requireData().version;axios$2.toFormData=requireToFormData();axios$2.AxiosError=requireAxiosError();axios$2.Cancel=axios$2.CanceledError;axios$2.all=function all(promises){return Promise.all(promises)};axios$2.spread=requireSpread();axios$2.isAxiosError=requireIsAxiosError();axios$3.exports=axios$2;axios$3.exports.default=axios$2;var axiosExports=axios$3.exports;var axios=axiosExports;var axios$1=getDefaultExportFromCjs(axios);function sleep(time=1e3){return new Promise((resolve,reject)=>setTimeout(resolve,time))}class HttpProvider extends BaseProvider{constructor(options){super(options)}async _transport(data){let leftTries=this.retry;let error=null;while(leftTries>0){try{const response=await axios$1({url:this.url,method:"post",data:data,timeout:this.timeout});return response.data}catch(_error){error=_error}await sleep(1e3);leftTries--}throw error}_transportBatch(data){return this._transport(data)}}class StorageNode extends HttpProvider{constructor(url){super({url:url})}async getStatus(){const res=await super.request({method:"zgs_getStatus"});return res}async uploadSegment(seg){const res=await super.request({method:"zgs_uploadSegment",params:[seg]});return res}async uploadSegments(segs){const res=await super.request({method:"zgs_uploadSegments",params:[segs]});return res}async downloadSegment(root,startIndex,endIndx){var seg=await super.request({method:"zgs_downloadSegment",params:[root,startIndex,endIndx]});return seg}async downloadSegmentWithProof(root,index){const seg=await super.request({method:"zgs_downloadSegmentWithProof",params:[root,index]});return seg}async getFileInfo(root){const info=await super.request({method:"zgs_getFileInfo",params:[root]});return info}async getFileInfoByTxSeq(txSeq){const info=await super.request({method:"zgs_getFileInfoByTxSeq",params:[txSeq]});return info}}class StorageKv extends HttpProvider{constructor(url){super({url:url})}async getValue(streamId,key,startIndex,length,version){var params=[streamId,key,startIndex,length];if(version!==undefined){params.push(version)}const res=await super.request({method:"kv_getValue",params:params});return res}async GetNext(streamId,key,startIndex,length,inclusive,version){var params=[streamId,key,startIndex,length,inclusive];if(version!==undefined){params.push(version)}const res=await super.request({method:"kv_getNext",params:params});return res}async getPrev(streamId,key,startIndex,length,inclusive,version){var params=[streamId,key,startIndex,length,inclusive];if(version!==undefined){params.push(version)}const res=await super.request({method:"kv_getPrev",params:params});return res}async getFirst(streamId,startIndex,length,version){var params=[streamId,startIndex,length];if(version!==undefined){params.push(version)}const res=await super.request({method:"kv_getFirst",params:params});return res}async getLast(streamId,startIndex,length,version){var params=[streamId,startIndex,length];if(version!==undefined){params.push(version)}const res=await super.request({method:"kv_getLast",params:params});return res}async getTransactionResult(txSeq){const res=await super.request({method:"kv_getTransactionResult",params:[txSeq]});return res}async getHoldingStreamIds(){const res=await super.request({method:"kv_getHoldingStreamIds"});return res}async hasWritePermission(account,streamId,key,version){var params=[account,streamId,key];if(version!==undefined){params.push(version)}const res=await super.request({method:"kv_hasWritePermission",params:params});return res}async IsAdmin(account,streamId,version){var params=[account,streamId];if(version!==undefined){params.push(version)}const res=await super.request({method:"kv_IsAdmin",params:params});return res}async isSpecialKey(stremId,key,version){var params=[stremId,key];if(version!==undefined){params.push(version)}const res=await super.request({method:"kv_isSpecialKey",params:params});return res}}class LeafNode{hash;parent=null;left=null;right=null;constructor(hash){this.hash=hash}static fromContent(content){return new LeafNode(keccak256$1(content))}static fromLeftAndRight(left,right){const node=new LeafNode(keccak256Hash(left.hash,right.hash));node.left=left;node.right=right;left.parent=node;right.parent=node;return node}isLeftSide(){return this.parent!==null&&this.parent.left===this}}var NHProofErrors;(function(NHProofErrors){NHProofErrors["WRONG_FORMAT"]="invalid merkle proof format";NHProofErrors["ROOT_MISMATCH"]="merkle proof root mismatch";NHProofErrors["CONTENT_MISMATCH"]="merkle proof content mismatch";NHProofErrors["POSITION_MISMATCH"]="merkle proof position mismatch";NHProofErrors["VALIDATION_FAILURE"]="failed to validate merkle proof"})(NHProofErrors||(NHProofErrors={}));class NeuraProof{lemma=[];path=[];constructor(lemma=[],path=[]){this.lemma=lemma;this.path=path}validateFormat(){const numSiblings=this.path.length;if(numSiblings===0){if(this.lemma.length!==1){return NHProofErrors.WRONG_FORMAT}return null}if(numSiblings+2!==this.lemma.length){return NHProofErrors.WRONG_FORMAT}return null}validate(rootHash,content,position,numLeafNodes){const contentHash=keccak256$1(content);return this.validateHash(rootHash,contentHash,position,numLeafNodes)}validateHash(rootHash,contentHash,position,numLeafNodes){const formatError=this.validateFormat();if(formatError!==null){return formatError}if(contentHash!==this.lemma[0]){return NHProofErrors.CONTENT_MISMATCH}if(this.lemma.length>1&&rootHash!==this.lemma[this.lemma.length-1]){return NHProofErrors.ROOT_MISMATCH}const proofPosition=this.calculateProofPosition(numLeafNodes);if(proofPosition!==position){return NHProofErrors.POSITION_MISMATCH}if(!this.validateRoot()){return NHProofErrors.VALIDATION_FAILURE}return null}validateRoot(){let hash=this.lemma[0];for(let i=0;i<this.path.length;i++){const isLeft=this.path[i];if(isLeft){hash=keccak256Hash(hash,this.lemma[i+1])}else{hash=keccak256Hash(this.lemma[i+1],hash)}}return hash===this.lemma[this.lemma.length-1]}calculateProofPosition(numLeafNodes){let position=0;for(let i=this.path.length-1;i>=0;i--){const leftSideDepth=Math.ceil(Math.log2(numLeafNodes));const leftSideLeafNodes=Math.pow(2,leftSideDepth)/2;const isLeft=this.path[i];if(isLeft){numLeafNodes=leftSideLeafNodes}else{position+=leftSideLeafNodes;numLeafNodes-=leftSideLeafNodes}}return position}}class NHMerkleTree{root=null;leaves=[];constructor(root=null,leaves=[]){this.root=root;this.leaves=leaves}rootHash(){return this.root?this.root.hash:null}proofAt(i){if(i<0||i>=this.leaves.length){throw new Error("Index out of range")}if(this.leaves.length===1){return new NeuraProof([this.rootHash()],[])}const proof=new NeuraProof;proof.lemma.push(this.leaves[i].hash);let current=this.leaves[i];while(current!==this.root){if(current.isLeftSide()){proof.lemma.push(current.parent?.right?.hash);proof.path.push(true)}else{proof.lemma.push(current.parent?.left?.hash);proof.path.push(false)}current=current.parent}proof.lemma.push(this.rootHash());return proof}addLeaf(leafContent){this.leaves.push(LeafNode.fromContent(leafContent))}addLeafByHash(leafHash){this.leaves.push(new LeafNode(leafHash))}build(){const numLeafNodes=this.leaves.length;if(numLeafNodes===0){return null}let queue=[];for(let i=0;i<numLeafNodes;i+=2){if(i===numLeafNodes-1){queue.push(this.leaves[i]);continue}const node=LeafNode.fromLeftAndRight(this.leaves[i],this.leaves[i+1]);queue.push(node)}while(true){const numNodes=queue.length;if(numNodes<=1){break}for(let i=0;i<Math.floor(numNodes/2);i++){const left=queue[0];const right=queue[1];queue.splice(0,2);queue.push(LeafNode.fromLeftAndRight(left,right))}if(numNodes%2===1){const first=queue[0];queue.splice(0,1);queue.push(first)}}this.root=queue[0];return this}}function keccak256Hash(...hashes){return keccak256$1(hexConcat(hashes))}function numSplits(total,unit){return Math.floor((total-1)/unit)+1}function nextPow2(input){let x=input;x-=1;x|=x>>32;x|=x>>16;x|=x>>8;x|=x>>4;x|=x>>2;x|=x>>1;x+=1;return x}function computePaddedSize(chunks){let chunksNextPow2=nextPow2(chunks);if(chunksNextPow2===chunks){return[chunksNextPow2,chunksNextPow2]}let minChunk;if(chunksNextPow2>=16){minChunk=Math.floor(chunksNextPow2/16)}else{minChunk=1}const paddedChunks=numSplits(chunks,minChunk)*minChunk;return[paddedChunks,chunksNextPow2]}class BlobIterator{file=null;buf;bufSize=0;fileSize;paddedSize;offset=0;batchSize;constructor(file,fileSize,offset,batch,flowPadding){if(batch%DEFAULT_CHUNK_SIZE>0){throw new Error("batch size should align with chunk size")}const buf=new Uint8Array(batch);const chunks=numSplits(fileSize,DEFAULT_CHUNK_SIZE);let paddedSize;if(flowPadding){const[paddedChunks]=computePaddedSize(chunks);paddedSize=paddedChunks*DEFAULT_CHUNK_SIZE}else{paddedSize=chunks*DEFAULT_CHUNK_SIZE}this.file=file;this.buf=buf;this.fileSize=fileSize;this.paddedSize=paddedSize;this.batchSize=batch;this.offset=offset}static NewSegmentIterator(file,fileSize,offset,flowPadding){return new BlobIterator(file,fileSize,offset,DEFAULT_SEGMENT_SIZE,flowPadding)}async readFromFile(start,end){if(start<0||start>=this.fileSize){throw new Error("invalid start offset")}if(end>this.fileSize){end=this.fileSize}const buf=await this.file?.slice(start,end).arrayBuffer();const buffer=new Uint8Array(this.batchSize);buffer.set(new Uint8Array(buf));return{bytesRead:buf.byteLength,buffer:buffer}}clearBuffer(){this.bufSize=0}paddingZeros(length){const startOffset=this.bufSize;this.buf=this.buf.fill(0,startOffset,startOffset+length);this.bufSize+=length;this.offset+=length}async next(){if(this.offset<0||this.offset>=this.paddedSize){return[false,null]}let expectedBufSize;let maxAvailableLength=this.paddedSize-this.offset;if(maxAvailableLength>=this.batchSize){expectedBufSize=this.batchSize}else{expectedBufSize=maxAvailableLength}this.clearBuffer();if(this.offset>=this.fileSize){this.paddingZeros(expectedBufSize);return[true,null]}const{bytesRead:n,buffer}=await this.readFromFile(this.offset,this.offset+this.batchSize);this.buf=buffer;this.bufSize=n;this.offset+=n;if(n===expectedBufSize){return[true,null]}if(n>expectedBufSize){throw new Error("load more data from file than expected")}if(expectedBufSize>n){this.paddingZeros(expectedBufSize-n)}return[true,null]}current(){return this.buf.subarray(0,this.bufSize)}}class NodeFdIterator extends BlobIterator{fd=null;constructor(fd,fileSize,offset,batch,flowPadding){super(null,fileSize,offset,batch,flowPadding);this.fd=fd}async readFromFile(start,end){if(start<0||start>=this.fileSize){throw new Error("invalid start offset")}if(end>this.fileSize){end=this.fileSize}const res=await this.fd?.read({buffer:this.buf,offset:this.bufSize,length:end-start,position:start});return res}}class AbstractFile{fileSize=0;static segmentRoot(segment,emptyChunksPadded=0){const tree=new NHMerkleTree;const dataLength=segment.length;for(let offset=0;offset<dataLength;offset+=DEFAULT_CHUNK_SIZE){const chunk=segment.subarray(offset,offset+DEFAULT_CHUNK_SIZE);tree.addLeaf(chunk)}if(emptyChunksPadded>0){for(let i=0;i<emptyChunksPadded;i++){tree.addLeafByHash(EMPTY_CHUNK_HASH)}}tree.build();if(tree.root!==null){return tree.rootHash()}return ZERO_HASH}size(){return this.fileSize}iterate(flowPadding){return this.iterateWithOffsetAndBatch(0,DEFAULT_SEGMENT_SIZE,flowPadding)}async merkleTree(){const iter=this.iterate(true);const tree=new NHMerkleTree;while(true){let[ok,err]=await iter.next();if(err!=null){return[null,err]}if(!ok){break}const current=iter.current();const segRoot=AbstractFile.segmentRoot(current);tree.addLeafByHash(segRoot)}return[tree.build(),null]}numChunks(){return numSplits(this.size(),DEFAULT_CHUNK_SIZE)}numSegments(){return numSplits(this.size(),DEFAULT_SEGMENT_SIZE)}async createSubmission(tags){const submission={length:this.size(),tags:tags,nodes:[]};const nodes=this.splitNodes();let offset=0;for(let chunks of nodes){let[node,err]=await this.createNode(offset,chunks);if(err!=null){return[null,err]}submission.nodes.push(node);offset+=chunks*DEFAULT_CHUNK_SIZE}return[submission,null]}splitNodes(){let nodes=[];let chunks=this.numChunks();let[paddedChunks,chunksNextPow2]=computePaddedSize(chunks);let nextChunkSize=chunksNextPow2;while(paddedChunks>0){if(paddedChunks>=nextChunkSize){paddedChunks-=nextChunkSize;nodes.push(nextChunkSize)}nextChunkSize/=2}return nodes}async createNode(offset,chunks){let batch=chunks;if(chunks>DEFAULT_SEGMENT_MAX_CHUNKS){batch=DEFAULT_SEGMENT_MAX_CHUNKS}return this.createSegmentNode(offset,DEFAULT_CHUNK_SIZE*batch,DEFAULT_CHUNK_SIZE*chunks)}async createSegmentNode(offset,batch,size){const iter=this.iterateWithOffsetAndBatch(offset,batch,true);const tree=new NHMerkleTree;for(let i=0;i<size;){let[ok,err]=await iter.next();if(err!=null){return[null,err]}if(!ok){break}const current=iter.current();const segRoot=AbstractFile.segmentRoot(current);tree.addLeafByHash(segRoot);i+=current.length}tree.build();const numChunks=size/DEFAULT_CHUNK_SIZE;const height=Math.log2(numChunks);const node={height:height,root:tree.rootHash()};return[node,null]}}class NHBlob extends AbstractFile{blob=null;fileSize=0;constructor(blob){super();this.blob=blob;this.fileSize=blob.size}iterateWithOffsetAndBatch(offset,batch,flowPadding){return new BlobIterator(this.blob,this.size(),offset,batch,flowPadding)}}class NHFile extends AbstractFile{fd=null;fileSize=0;constructor(fd,fileSize){super();this.fd=fd;this.fileSize=fileSize}static async fromNodeFileHandle(fd){const stat=await fd.stat();return new NHFile(fd,stat.size)}static async fromFilePath(path){const fd=await open(path,"r");return await NHFile.fromNodeFileHandle(fd)}async close(){await this.fd?.close()}iterateWithOffsetAndBatch(offset,batch,flowPadding){return new NodeFdIterator(this.fd,this.size(),offset,batch,flowPadding)}}export{DEFAULT_CHUNK_SIZE,DEFAULT_SEGMENT_MAX_CHUNKS,DEFAULT_SEGMENT_SIZE,Downloader,EMPTY_CHUNK,EMPTY_CHUNK_HASH,Flow__factory,GetSplitNum,LeafNode,NHBlob,NHFile,NHMerkleTree,NHProofErrors,NeuraProof,SMALL_FILE_SIZE_THRESHOLD,StorageKv,StorageNode,TESTNET_FLOW_ADDRESS,Uploader,ZERO_HASH,checkExist,computePaddedSize,index as factories,getFlowContract,nextPow2,numSplits};